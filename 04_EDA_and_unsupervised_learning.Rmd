---
title: "04_EDA_and_unsupervised_learning"
author: "Fran Camacho"
date: "2025-08-19"
output:
  word_document: default
  pdf_document: default
  html_document:
    df_print: paged
---


# 4 - Exploratory data analysis and unsupervised learning

https://modernstatisticswithr.com/eda.html#eda

`x = 2 * z`


```{r}
#Libraries

#https://tidyverse.r-universe.dev/tidyverse
if (!require(tidyverse)) install.packages('tidyverse', repos = c('https://tidyverse.r-universe.dev', 'https://cloud.r-project.org'))
library(tidyverse)

#Additional themes for ggplot2
#if (!require(hrbrthemes)) install.packages('hrbrthemes', dependencies = T)
#install.packages("hrbrthemes")
#if (!require(ggthemes)) install.packages('ggthemes', dependencies = T)
#install.packages("ggthemes")

#if (!require(patchwork)) install.packages('patchwork', dependencies = T)
#library(patchwork)

# interactive version of plots? <- very heavy???
#if (!require(plotly)) install.packages('plotly', dependencies = T)
#library(plotly)

```


Exploratory data analysis (EDA) is a process in which we summarise and visually explore a dataset.
An important part of EDA is unsupervised learning, which is a collection of methods for finding interesting subgroups and patterns in our data. 
Unlike statistical hypothesis testing, which is used to reject hypotheses, EDA can be used to generate hypotheses
(which can then be confirmed or rejected by new studies). Another purpose of EDA is to find outliers and incorrect observations,
which can lead to a cleaner and more useful dataset.

...


## 4.1 Reports with R Markdown

...

### Formatting text

To create plain text in a Markdown file, you simply have to write plain text. 
If you wish to add some formatting to your text, you can use the following:

- _italics_ or *italics*: to create text in italics.

- __bold__ or **bold**: to create bold text.

- [linked text](http://www.modernstatisticswithr.com): to create linked text.

- `code`: to include inline code in your document.

- to create inline equations like a2+b2=c2 using LaTeX syntax:  $a^2 + b^2 = c^2$

- to create a centred equation on a new line: $$a^2 + b^2 = c^2$$: 

...


### Lists, tables, and images


To create a **bullet list**, you can use * as follows. Note that you need a blank line between your list and the previous paragraph to begin a list.

* Item 1
* Item 2
   + Sub-item 1
   + Sub-item 2
* Item 3


To create an **ordered list**, use:

1. First item
2. Second item
  i) Sub-item 1
  ii) Sub-item 2
3. Item 3

To create a **table**, use | and --------- as follows:

Column 1  | Column 2
--------- | ---------
Content  | More content
Even more  | And some here
Even more?  | Yes!


To include an **image**, use the same syntax as when creating linked text with a link to the image path 
(either local or on the web), but with a ! in front:

![](https://www.r-project.org/Rlogo.png)

![The R logo.](https://www.r-project.org/Rlogo.png)


### Code chunks

In RStudio, **Ctrl+Alt+I** is a keyboard shortcut for inserting this kind of code chunk:

```{r}

```

We can add a name and a caption to the chunk, which lets us reference objects created by the chunk:

```{r pressureplot, fig.cap = "Plot of the pressure data."}
plot(pressure)
```

As we can see in Figure \@ref(fig:pressureplot), the relationship between temperature and pressure resembles a banana.

In addition, you can add settings to the chunk header to control its behaviour:

- echo = FALSE      to run the code without printing it,
- eval = FALSE      to print the code without running it,
- results = "hide"  to hide printed output,
- fig.show = "hide" to hide plots,
- warning = FALSE   to suppress warning messages from being printed in your document,
- message = FALSE   to suppress other messages from being printed in your document,
- include = FALSE   to run a chunk without showing the code or results in the document,
- error = TRUE      to continue running your R Markdown document even if there is an error in the chunk 
                    (by default, the documentation creation stops if there is an error).


Data frames can be printed either as in the Console or as a nicely formatted table. 

For example:

```{r}
head(airquality)
```
whereas yields a nicely formatted table:

```{r}
knitr::kable(
  head(airquality),
  caption = "Some data I found."
)
```



## 4.2 Customising ggplot2 plots

We’ll be using ggplot2 a lot in this chapter; so, before we get started with exploratory analyses,
we’ll take some time to learn how we can customise the look of ggplot2-plots.

Consider the following facetted plot from Section 2.7.4:

```{r}
library(ggplot2)

ggplot(msleep, aes(brainwt, sleep_total)) + 
      geom_point() +
      labs(x = "Brain weight (logarithmic scale)",
           y = "Total sleep time") +
      scale_x_log10() +
      facet_wrap(~ vore)
```

It looks nice, sure, but there may be things that you’d like to change. Maybe you’d like the plot’s background to be white instead of grey, 
or perhaps you’d like to use a different font. These, and many other things, can be modified using *themes* and *palettes*. 
Before we look at that, we’ll take a quick look at how to modify the labels and axes of the plot.


### Modifying labels

```{r}
ggplot(msleep, aes(brainwt, sleep_total, colour = vore)) + 
      geom_point() +
      labs(x = "Brain weight (logarithmic scale)",
           y = "Total sleep time",
           colour = "Feeding behaviour") +
      scale_x_log10()
```


### Modifying axis scales

We’ve seen how functions with names beginning with scale_x, such as scale_x_log10 can be used to modify the scale of the x-axis 
(and scale_y-functions used to modify the y-axis). In addition to log transforms, we can for instance control where the tick marks 
are located by using the breaks argument. If we only want to modify the tick marks (without doing a log transform), 
we can use **scale_x_continuous**:

```{r}
# Default:
ggplot(msleep, aes(brainwt, sleep_total, colour = vore)) + 
      geom_point() +
      labs(x = "Brain weight",
           y = "Total sleep time",
           colour = "Feeding behaviour")
```


```{r}
# Tick marks at all integers from 0 to 6:
ggplot(msleep, aes(brainwt, sleep_total, colour = vore)) + 
      geom_point() +
      labs(x = "Brain weight",
           y = "Total sleep time",
           colour = "Feeding behaviour") +
      scale_x_continuous(breaks = 0:6)
```


```{r}
# Tick mark at specific values:
ggplot(msleep, aes(brainwt, sleep_total, colour = vore)) + 
      geom_point() +
      labs(x = "Brain weight",
           y = "Total sleep time",
           colour = "Feeding behaviour") +
      scale_x_continuous(breaks = c(0, 2.5, 4.25))
```


### Using themes

ggplot2 comes with a number of basic themes. All are fairly similar but differ in things like background colour, grids, and borders.
You can add them to your plot using theme_themeName, where themeName is the name of the theme24. Here are some examples:

```{r}
p <- ggplot(msleep, aes(brainwt, sleep_total, colour = vore)) + 
      geom_point() +
      labs(x = "Brain weight (logarithmic scale)",
           y = "Total sleep time",
           colour = "Feeding behaviour") +
      scale_x_log10() +
      facet_wrap(~ vore)

# Create plot with different themes:
p + theme_grey() # The default theme
p + theme_bw()
p + theme_linedraw()
p + theme_light()
p + theme_dark()
p + theme_minimal()
p + theme_classic()
```


There are several packages available that contain additional themes. Let’s try a few:

```{r}
#install.packages("ggthemes")
library(ggthemes)

# Create plot with different themes from ggthemes:
p + theme_tufte() # Minimalist Tufte theme
p + theme_wsj() # Wall Street Journal
p + theme_solarized() + scale_colour_solarized() # Solarized colours
```


```{r}
#install.packages("hrbrthemes")
library(hrbrthemes)

# Create plot with different themes from hrbrthemes:
p + theme_ipsum() # Ipsum theme
p + theme_ft_rc() # Suitable for use with dark RStudio themes
p + theme_modern_rc() # Suitable for use with dark RStudio themes
```


###  Colour palettes

Unlike, e.g., background colours, the colour palette, i.e., the list of colours used for plotting, is not part of the theme that you’re using.
Next, we’ll have a look at how to change the colour palette used for your plot.

Let’s start by creating a ggplot object:

```{r}
p <- ggplot(msleep, aes(brainwt, sleep_total, colour = vore)) + 
      geom_point() +
      labs(x = "Brain weight (logarithmic scale)",
           y = "Total sleep time",
           colour = "Feeding behaviour") +
      scale_x_log10()
```

You can change the colour palette using scale_colour_brewer. Three types of colour palettes are available:

- **Sequential palettes**: these range from a colour to white. These are useful for representing ordinal 
(i.e., ordered) categorical variables and numerical variables.

- **Diverging palettes**: these range from one colour to another, with white in between. 
Diverging palettes are useful when there is a meaningful middle or 0 value 
(e.g., when your variables represent temperatures or profit/loss), which can be mapped to white.

- **Qualitative palettes**: these contain multiple distinct colours. They are useful for nominal (i.e., with no natural ordering) categorical variables.

See ?scale_colour_brewer or visit http://www.colorbrewer2.org for a list of the available palettes.
Here are some examples:

```{r}
# Sequential palette:
p + scale_colour_brewer(palette = "OrRd")
```


```{r}
# Diverging palette:
p + scale_colour_brewer(palette = "RdBu")
```


```{r}
# Qualitative palette:
p + scale_colour_brewer(palette = "Set1")
```

In this case, because vore is a nominal categorical variable, a qualitative palette is arguably the best choice.

In addition to these ready-made palettes, you can create your own custom palettes. 
...


###  Theme settings

The point of using a theme is that you get a combination of colours, fonts, and other choices that are supposed to go well together, 
meaning that you don’t have to spend too much time picking combinations. But if you like, you can override the default options 
and customise any and all parts of a theme.

The theme controls all visual aspects of the plot not related to the aesthetics. You can change the theme settings using the theme function. 
For instance, you can use theme to remove the legend or change its position:


```{r}
# No legend:
p + theme(legend.position = "none")

# Legend below figure:
p + theme(legend.position = "bottom")

# Legend inside plot:
p + theme(legend.position.inside = c(0.9, 0.7))
```

The base size of a theme controls the scale of the entire figure. This makes it useful when you want to rescale all elements of your plot at the same time:

```{r}
p + theme_grey(base_size = 8)
p + theme_grey(base_size = 20)
```
theme has a lot of other settings, including for the colours of the background, the grid, and the text in the plot. 
Here are a few examples that you can use as a starting point for experimenting with the settings:

```{r}
p + theme(panel.grid.major = element_line(colour = "black"),
          panel.grid.minor = element_line(colour = "purple",
                                          linetype = "dotted"),
          panel.background = element_rect(colour = "red", size = 2),
          plot.background = element_rect(fill = "lightgreen"),
          axis.text = element_text(family = "mono", colour = "blue"),
          axis.title = element_text(family = "serif", size = 14))
```


## 4.3 Exploring distributions

It is often useful to visualise the distribution of a numerical variable. Comparing the distributions of different groups can lead to important insights. 
Visualising distributions is also essential when checking assumptions used for various statistical tests (sometimes called initial data analysis). 
In this section, we will illustrate how this can be done using the *diamonds* data from the ggplot2 package. You can read more about it by running *?diamonds*.


### Density plots and frequency polygons

We already know how to visualise the distribution of the data by dividing it into bins and plotting a histogram:

```{r}
library(ggplot2)

ggplot(diamonds, aes(carat)) +
      geom_histogram(colour = "black")
```

A similar plot is created using frequency polygons, which uses lines instead of bars to display the counts in the bins:

```{r}
ggplot(diamonds, aes(carat)) +
      geom_freqpoly()
```

An advantage with frequency polygons is that they can be used to compare groups, e.g., diamonds with different cuts, without facetting:

```{r}
p <- ggplot(diamonds, aes(carat, colour = cut)) +
     geom_freqpoly()

# Legend below figure:
p # + theme(legend.position = "bottom")
```

It is clear from this figure that there are more diamonds with ideal cuts than diamonds with fair cuts in the data. 
The polygons have roughly the same shape, except perhaps for the polygon for diamonds with fair cuts.

In some cases, we are more interested in the shape of the distribution than in the actual counts in the different bins.
Density plots are similar to frequency polygons but show an estimate of the density function of the underlying random variable.
These estimates are smooth curves that are scaled so that the area below them is 1 (i.e., scaled to be proper density functions):

```{r}
ggplot(diamonds, aes(carat, colour = cut)) +
      geom_density()
```

From this figure, it becomes clear that low-carat diamonds tend to have better cuts, which wasn’t obvious from the frequency polygons. 
However, the plot does not provide any information about how common different cuts are. Use density plots if you’re more interested 
in the shape of a variable’s distribution, and frequency polygons if you’re more interested in counts.




**Exercise 4.2**

Using the density plot we just created above and the documentation for geom_density, do the following:

- Increase the smoothness of the density curves.

```{r}
ggplot(diamonds, aes(carat, colour = cut)) +
      geom_density(bw = 0.25)
```

- Fill the area under the density curves with the same colour as the curves themselves.

```{r}
ggplot(diamonds, aes(carat, colour = cut, fill = cut)) +
      geom_density(bw = 0.25)
```

- Make the colours that fill the areas under the curves transparent.

Because the densities overlap, it’d be better to make the fill colours slightly transparent. We add alpha to the geom:

```{r}
ggplot(diamonds, aes(carat, colour = cut, fill = cut)) +
      geom_density(bw = 0.2, alpha = 0.25)
```

- The figure still isn’t that easy to interpret. Install and load the ggridges package, an extension of ggplot2 that allows you to make so-called ridge plots
(density plots that are separated along the y-axis, similar to facetting). 
Read the documentation for geom_density_ridges and use it to make a ridge plot of diamond prices for different cuts.

A similar plot can be created using geom_density_ridges from the **ggridges** package. 
Note that you must set y = cut in the aes, because the densities should be separated by cut.

```{r}
if (!require(ggridges)) install.packages('ggridges', dependencies = T)
library(ggridges)

ggplot(diamonds, aes(carat, cut, fill = cut)) +
      geom_density_ridges()
```

**Exercise 4.3**

Return to the histogram created by ggplot(diamonds, aes(carat)) + geom_histogram() above. 
As there are very few diamonds with carat greater than 3, cut the x-axis at 3. 
Then decrease the bin width to 0.01. Do any interesting patterns emerge?

```{r}
ggplot(diamonds, aes(carat)) +
      geom_histogram(binwidth = 0.01) +
      xlim(0, 3)
```
It appears that carat values that are just above multiples of 0.25 are more common than other values. 
We’ll explore that next.


### Asking questions

Exercise 4.3 above causes us to ask why diamonds with carat values that are multiples of 0.25 are more common than others. 
Perhaps the price is involved? Unfortunately, a plot of carat versus price is not that informative:

```{r}
ggplot(data = diamonds, mapping = aes(carat, price)) +
      geom_point(size = 0.05)
```

Maybe we could compute the average price in each bin of the histogram? In that case, we need to extract the bin breaks from the histogram somehow. 
We could then create a new categorical variable using the breaks with cut (as we did in Exercise 2.27). 
It turns out that extracting the bins is much easier using base graphics than ggplot2, so let’s do that:

```{r}
# Extract information from a histogram with bin width 0.01, which corresponds to 481 breaks:
carat_br <- hist(diamonds$carat, breaks = 481, right = FALSE, plot = FALSE)

# Of interest to us are:
# carat_br$breaks, which contains the breaks for the bins
# carat_br$mid, which contains the midpoints of the bins (useful for plotting!)

# Create categories for each bin:
diamonds$carat_cat <- cut(diamonds$carat, 481, right = FALSE)
```

We now have a variable, carat_cat, that shows to which bin each observation belongs. Next, we’d like to compute the mean for each bin. 
This is a grouped summary – mean by category. After we’ve computed the bin means, we could then plot them against the bin midpoints. 
Let’s try it:

```{r}
means <- aggregate(price ~ carat_cat, data = diamonds, FUN = mean)

plot(carat_br$mid, means$price)

#That didn’t work as intended. We get an error message when attempting to plot the results:
```

By default, aggregate ignores groups for which there are no values when computing grouped summaries. 
In this case, there are a lot of empty bins – there is for instance no observation in the [4.99,5) bin. 
In fact, only 272 out of the 481 bins are non-empty.

We can solve this in different ways. One way is to remove the empty bins. We can do this using the match function, 
which returns the positions of matching values in two vectors. If we use it with the bins from the grouped summary and 
the vector containing all bins, we can find the indices of the non-empty bins. 
This requires the use of the **levels** function, which you’ll learn more about in Section 5.4:

```{r}
means <- aggregate(price ~ carat_cat, data = diamonds, FUN = mean)

id <- match(means$carat_cat, levels(diamonds$carat_cat))
```

Finally, we’ll also add some vertical lines to our plot, to call attention to multiples of 0.25.

Using base graphics is faster here:
```{r}
plot(carat_br$mid[id], means$price, cex = 0.5)

# Add vertical lines at multiples
# of 0.25:
abline(v = c(0.5, 0.75, 1, 1.25, 1.5))
```

But we can of course stick to ggplot2 if we like:
```{r}
library(ggplot2)

d2 <- data.frame(bin = carat_br$mid[id], mean = means$price)

ggplot(d2, aes(bin, mean)) +
       geom_point() +
       geom_vline(xintercept = c(0.5, 0.75, 1, 1.25, 1.5))
       # geom_vline add vertical lines at multiples of 0.25
```

It appears that there are small jumps in the prices at some of the 0.25-marks. 
This explains why there are more diamonds just above these marks than just below.

The above example illustrates three crucial things regarding exploratory data analysis:

- Plots (in our case, the histogram) often lead to new questions.

- Often, we must transform, summarise, or otherwise manipulate our data to answer a question.
Sometimes this is straightforward, and sometimes it means diving deep into R code.

- Sometimes the thing that we’re trying to do doesn’t work straight away. There is almost always a solution though 
(and oftentimes more than one!). The more you work with R, the more problem-solving tricks you will learn.


### Violin plots

Density curves can also be used as alternatives to boxplots. In Exercise 2.17, you created boxplots to visualise price differences between diamonds of different cuts:

```{r}
ggplot(diamonds, aes(cut, price)) +
      geom_boxplot()
```

Instead of using a boxplot, we can use a **violin plot**. Each group is represented by a “violin”, given by a rotated and duplicated density plot:

```{r}
ggplot(diamonds, aes(cut, price)) +
      geom_violin()
```

Compared to boxplots, violin plots capture the entire distribution of the data rather than just a few numerical summaries. 
If you like numerical summaries (and you should) you can add the median and the quartiles 
(corresponding to the borders of the box in the boxplot) using the draw_quantiles argument:

```{r}
ggplot(diamonds, aes(cut, price)) +
      geom_violin(draw_quantiles =  c(0.25, 0.5, 0.75))
```




**Exercise 4.4 **
Using the first boxplot created above, i.e., ggplot(diamonds, aes(cut, price)) + geom_violin(), do the following:

- Add some colour to the plot by giving different colours to each violin.

```{r}
ggplot(diamonds, aes(cut, price, fill = cut)) + 
  geom_violin()
```

- Because the categories are shown along the x-axis, we don’t really need the legend. Remove it.

```{r}
ggplot(diamonds, aes(cut, price, fill = cut)) + 
  geom_violin() +
  theme(legend.position = "none")
```

- Both boxplots and violin plots are useful. Maybe we can have the best of both worlds? Add the corresponding boxplot inside each violin. 
Hint: the width and alpha arguments in geom_boxplot are useful for creating a nice-looking figure here.

```{r}
ggplot(diamonds, aes(cut, price)) +
      geom_violin(aes(fill = cut), width = 1.25) +
      geom_boxplot(width = 0.1, alpha = 0.5) +
      theme(legend.position = "none")
```

- Flip the coordinate system to create horizontal violins and boxes instead.

```{r}
ggplot(diamonds, aes(cut, price)) +
      geom_violin(aes(fill = cut), width = 1.25) +
      geom_boxplot(width = 0.1, alpha = 0.5) +
      theme(legend.position = "none") +
      coord_flip()
```



## 4.4 Combining multiple plots into a single graphic

When exploring data with many variables, you’ll often want to make the same kind of plot (e.g., a violin plot) for several variables. 
It will frequently make sense to place these side-by-side in the same plot window. The patchwork package extends ggplot2 by letting you do just that.

Let’s install it: (at the beginning of the .Rmd)

And use it:

```{r}
plot1 <- ggplot(diamonds, aes(cut, carat, fill = cut)) +
            geom_violin() +
            theme(legend.position = "none")

plot2 <- ggplot(diamonds, aes(cut, price, fill = cut)) +
            geom_violin() +
            theme(legend.position = "none")

library(patchwork)
plot1 + plot2
```

You can also arrange the plots on multiple lines, with different numbers of plots on each line. 
This is particularly useful if you are combining different types of plots in a single plot window. 
In this case, you separate plots that are one the same line by | and mark the beginning of a new line with /:

```{r}
# Create two more plot objects:
plot3 <- ggplot(diamonds, aes(cut, depth, fill = cut)) +
            geom_violin() +
            theme(legend.position = "none")

plot4 <- ggplot(diamonds, aes(carat, fill = cut)) +
            geom_density(alpha = 0.5) +
            theme(legend.position = c(0.9, 0.6))

# One row with three plots and one row with a single plot:
(plot1 | plot2 | plot3) / plot4
```


```{r}
# One column with three plots and one column with a single plot:
(plot1 / plot2 / plot3) | plot4
```

## 4.5 Outliers and missing data

### Detecting outliers

Both boxplots and scatterplots are helpful in detecting deviating observations – often called outliers. 
Outliers can be caused by measurement errors or errors in the data input but can also be interesting rare cases that can provide 
valuable insights about the process that generated the data. 
Either way, it is often of interest to detect outliers, for instance because that may influence the choice of what statistical tests to use.

Let’s draw a scatterplot of diamond carats versus prices:

```{r}
ggplot(diamonds, aes(carat, price)) +
      geom_point()
```

There are some outliers which we may want to study further. For instance, there is a surprisingly cheap 5-carat diamond, 
and some cheap 3-carat diamonds. Note that it is not just the prices nor just the carats of these diamonds that make them outliers, 
but the unusual combinations of prices and carats. But how can we identify those points?

One option is to use the plotly package to make an interactive version of the plot, where we can hover interesting points to see more information about them. 
Start by installing it:
(Above)

```{r}
#install.packages("plotly")
```

To use **plotly** with a ggplot graphic, we store the graphic in a variable and then use it as input to the ggplotly function. 
The resulting (interactive!) plot takes a little longer than usual to load. Try hovering the points:

```{r}
myPlot <- ggplot(diamonds, aes(carat, price)) +
      geom_point()

library(plotly)
ggplotly(myPlot)
```

By default, plotly only shows the carat and price of each diamond. But we can add more information to the box by adding a text aesthetic:


```{r}
myPlot <- ggplot(diamonds, aes(carat, price, text = paste("Row:", rownames(diamonds)))) +
          geom_point()

ggplotly(myPlot)
```

We can now find the row numbers of the outliers visually, which is very useful when exploring data.

**Exercise 4.5**
The variables x and y in the diamonds data describe the length and width of the diamonds (in millimetres). 
Use an interactive scatterplot to identify outliers in these variables. 
Check prices, carat, and other information and think about if any of the outliers can be due to data errors.

```{r}
myPlot <- ggplot(diamonds, aes(x, y, text = paste("Row:", rownames(diamonds)))) +
      geom_point()

ggplotly(myPlot)
```

There are outliers along the y-axis on rows 24,068 and 49,190. 
There are also some points for which x=0. Examples include rows 11,183 and 49,558. 
It isn’t clear from the plot, but in total there are 8 such points, 7 of which have both x=0 and y=0.
To view all such diamonds, you can use filter(diamonds, x==0). 
These observations must be due to data errors, since diamonds can’t have 0 width.
The high y-values also seem suspicious - carat is a measure of diamond weight, and if these diamonds really were 10 times longer than others 
then we would probably expect them to have unusually high carat values as well (which they don’t).


### Labelling outliers

Interactive plots are great when exploring a dataset but are not always possible to use in other contexts, e.g., for printed reports and some presentations. 
In these other cases, we can instead annotate the plot with notes about outliers. One way to do this is to use a geom called **geom_text**.

For instance, we may want to add the row numbers of outliers to a plot. To do so, we use geom_text along with a condition that specifies for which points we should add annotations.

...

Here are some different examples of conditions used to plot text:

```{r}
# Using the row number (the 5 carat diamond is on row 27,416)
ggplot(diamonds, aes(carat, price)) +
      geom_point() +
      geom_text(aes(label = ifelse(rownames(diamonds) == 27416,
                                   rownames(diamonds), "")),
                hjust = 1.1)
# (hjust=1.1 shifts the text to the left of the point)
```


```{r}
# Plot text next to all diamonds with carat>4
ggplot(diamonds, aes(carat, price)) +
     geom_point() +
     geom_text(aes(label = ifelse(carat > 4, rownames(diamonds), "")),
               hjust = 1.1)
```


```{r}
# Plot text next to 3 carat diamonds with a price below 7500
ggplot(diamonds, aes(carat, price)) +
      geom_point() +
      geom_text(aes(label = ifelse(carat == 3 & price < 7500,
                                   rownames(diamonds), "")),
                hjust = 1.1)
```

**Exercise 4.6**
Create a static (i.e., non-interactive) scatterplot of x versus y from the diamonds data. 
Label the diamonds with suspiciously high y-values.

```{r}
ggplot(diamonds, aes(x, y)) +
      geom_point() +
      geom_text(aes(label = ifelse(y > 20, rownames(diamonds), "")),
                hjust = 1.1)
```

### Missing data

Like many datasets, the mammal sleep data msleep contains a lot of missing values, represented by NA (Not Available) in R. 
This becomes evident when we have a look at the data:

```{r}
library(ggplot2)
View(msleep)
```

We can check if a particular observation is missing using the is.na function:

```{r}
is.na(msleep$sleep_rem[4])
is.na(msleep$sleep_rem)
```


Total NAs in the dataset by column:

```{r}
colSums(is.na(msleep))
```

Total NAs in the dataset:

```{r}
sum(is.na(msleep))
```

Total NAs in the dataset in one column:

```{r}
sum(is.na(msleep$sleep_rem))
```


You’ll notice that ggplot2 prints a warning in the Console when you create a plot with missing data:

```{r}
ggplot(msleep, aes(brainwt, sleep_total)) +
      geom_point() +
      scale_x_log10()
```

Sometimes, data are missing simply because the information is not yet available ...

It is of interest to see if there are any differences in non-missing variables between subjects that have missing data and subjects that don’t.

In msleep, all animals have recorded values for sleep_total and bodywt. To check if the animals that have missing brainwt values differ from the others,
we can plot them in a different colour in a scatterplot:

```{r}
ggplot(msleep, aes(bodywt, sleep_total, colour = is.na(brainwt))) +
      geom_point() +
      scale_x_log10()
```

(If is.na(brainwt) is TRUE, then the brain weight is missing in the dataset.) 

In this case, there are no apparent differences between the animals with missing data and those without.

**Exercise 4.7**
Create a version of the diamonds dataset where the x value is missing for all diamonds with x>9. 
Make a scatterplot of carat versus price, in which points where the x value is missing are plotted in a different colour. 
How would you interpret this plot?

```{r}
# Create a copy of diamonds, then replace x-values greater than 9
# with NA:
diamonds2 <- diamonds
diamonds2$x[diamonds2$x > 9] <- NA

## Create the scatterplot
ggplot(diamonds2, aes(carat, price, colour = is.na(x))) +
      geom_point()
```

In this plot, we see that virtually all high carat diamonds have missing x values. 
This seems to indicate that there is a systematic pattern to the missing data (which of course is correct in this case!), 
and we should proceed with any analyses of x with caution.


### Exploring data

The nycflights13 package contains data about flights to and from three airports in New York, USA, in 2013. 
As a summary exercise, we will study a subset of these, namely all flights departing from New York on 1 January of that year:

```{r}
install.packages("nycflights13")
library(nycflights13)

flights2 <- flights[flights$month == 1 & flights$day == 1,]
```

**Exercise 4.8**
Explore the flights2 dataset, focusing on delays and the amount of time spent in the air. Are there any differences between the different carriers? Are there missing data? Are there any outliers?

The code below is an example of what your analysis can look like, with some remarks as comments:

```{r}
# Investigate missing data
colSums(is.na(flights2))
# Not too much missing data in this dataset!

View(flights2[is.na(flights2$air_time),])
# Flights with missing data tend to have several missing variables.
```


```{r}
# Ridge plots to compare different carriers (boxplots, facetted
# histograms and violin plots could also be used)
library(ggridges)
ggplot(flights2, aes(arr_delay, carrier, fill = carrier)) +
      geom_density_ridges() +
      theme(legend.position = "none") +
      xlim(-50, 250)
# Some airlines (e.g. EV) appear to have a larger spread than others
```


```{r}
ggplot(flights2, aes(dep_delay, carrier, fill = carrier)) +
      geom_density_ridges() +
      theme(legend.position = "none") +
      xlim(-15, 100)
# Some airlines (e.g. EV) appear to have a larger spread others
```


```{r}
ggplot(flights2, aes(air_time, carrier, fill = carrier)) +
      geom_density_ridges() +
      theme(legend.position = "none")
# VX only do long-distance flights, whereas MQ, FL and 9E only do
# shorter flights
```

```{r}
# Make scatterplots and label outliers with flight numbers
ggplot(flights2, aes(dep_delay, arr_delay, colour = carrier)) +
      geom_point() +
      geom_text(aes(label = ifelse(arr_delay > 300,
                            paste("Flight", flight), "")),
                vjust = 1.2, hjust = 1)

ggplot(flights2, aes(air_time, arr_delay, colour = carrier)) +
      geom_point() +
      geom_text(aes(label = ifelse(air_time > 400 | arr_delay > 300,
                                   paste("Flight", flight), "")),
                vjust = 1.2, hjust = 1)
```


