---
title: "04_EDA_and_unsupervised_learning"
author: "Fran Camacho"
date: "2025-08-19"
output:
  word_document: default
  pdf_document: default
  html_document:
    df_print: paged
---


# 4 - Exploratory data analysis and unsupervised learning

https://modernstatisticswithr.com/eda.html#eda

`x = 2 * z`


```{r}
#Libraries

#https://tidyverse.r-universe.dev/tidyverse
if (!require(tidyverse)) install.packages('tidyverse', repos = c('https://tidyverse.r-universe.dev', 'https://cloud.r-project.org'))
library(tidyverse)

#Additional themes for ggplot2
if (!require(hrbrthemes)) install.packages('hrbrthemes', dependencies = T)
install.packages("hrbrthemes")
if (!require(ggthemes)) install.packages('ggthemes', dependencies = T)
install.packages("ggthemes")

if (!require(patchwork)) install.packages('patchwork', dependencies = T)
library(patchwork)

```


Exploratory data analysis (EDA) is a process in which we summarise and visually explore a dataset.
An important part of EDA is unsupervised learning, which is a collection of methods for finding interesting subgroups and patterns in our data. 
Unlike statistical hypothesis testing, which is used to reject hypotheses, EDA can be used to generate hypotheses
(which can then be confirmed or rejected by new studies). Another purpose of EDA is to find outliers and incorrect observations,
which can lead to a cleaner and more useful dataset.

...


## 4.1 Reports with R Markdown

...

### Formatting text

To create plain text in a Markdown file, you simply have to write plain text. 
If you wish to add some formatting to your text, you can use the following:

- _italics_ or *italics*: to create text in italics.

- __bold__ or **bold**: to create bold text.

- [linked text](http://www.modernstatisticswithr.com): to create linked text.

- `code`: to include inline code in your document.

- to create inline equations like a2+b2=c2 using LaTeX syntax:  $a^2 + b^2 = c^2$

- to create a centred equation on a new line: $$a^2 + b^2 = c^2$$: 

...


### Lists, tables, and images


To create a **bullet list**, you can use * as follows. Note that you need a blank line between your list and the previous paragraph to begin a list.

* Item 1
* Item 2
   + Sub-item 1
   + Sub-item 2
* Item 3


To create an **ordered list**, use:

1. First item
2. Second item
  i) Sub-item 1
  ii) Sub-item 2
3. Item 3

To create a **table**, use | and --------- as follows:

Column 1  | Column 2
--------- | ---------
Content  | More content
Even more  | And some here
Even more?  | Yes!


To include an **image**, use the same syntax as when creating linked text with a link to the image path 
(either local or on the web), but with a ! in front:

![](https://www.r-project.org/Rlogo.png)

![The R logo.](https://www.r-project.org/Rlogo.png)


### Code chunks

In RStudio, **Ctrl+Alt+I** is a keyboard shortcut for inserting this kind of code chunk:

```{r}

```

We can add a name and a caption to the chunk, which lets us reference objects created by the chunk:

```{r pressureplot, fig.cap = "Plot of the pressure data."}
plot(pressure)
```

As we can see in Figure \@ref(fig:pressureplot), the relationship between temperature and pressure resembles a banana.

In addition, you can add settings to the chunk header to control its behaviour:

- echo = FALSE      to run the code without printing it,
- eval = FALSE      to print the code without running it,
- results = "hide"  to hide printed output,
- fig.show = "hide" to hide plots,
- warning = FALSE   to suppress warning messages from being printed in your document,
- message = FALSE   to suppress other messages from being printed in your document,
- include = FALSE   to run a chunk without showing the code or results in the document,
- error = TRUE      to continue running your R Markdown document even if there is an error in the chunk 
                    (by default, the documentation creation stops if there is an error).


Data frames can be printed either as in the Console or as a nicely formatted table. 

For example:

```{r}
head(airquality)
```
whereas yields a nicely formatted table:

```{r}
knitr::kable(
  head(airquality),
  caption = "Some data I found."
)
```



## 4.2 Customising ggplot2 plots

We’ll be using ggplot2 a lot in this chapter; so, before we get started with exploratory analyses,
we’ll take some time to learn how we can customise the look of ggplot2-plots.

Consider the following facetted plot from Section 2.7.4:

```{r}
library(ggplot2)

ggplot(msleep, aes(brainwt, sleep_total)) + 
      geom_point() +
      labs(x = "Brain weight (logarithmic scale)",
           y = "Total sleep time") +
      scale_x_log10() +
      facet_wrap(~ vore)
```

It looks nice, sure, but there may be things that you’d like to change. Maybe you’d like the plot’s background to be white instead of grey, 
or perhaps you’d like to use a different font. These, and many other things, can be modified using *themes* and *palettes*. 
Before we look at that, we’ll take a quick look at how to modify the labels and axes of the plot.


### Modifying labels

```{r}
ggplot(msleep, aes(brainwt, sleep_total, colour = vore)) + 
      geom_point() +
      labs(x = "Brain weight (logarithmic scale)",
           y = "Total sleep time",
           colour = "Feeding behaviour") +
      scale_x_log10()
```


### Modifying axis scales

We’ve seen how functions with names beginning with scale_x, such as scale_x_log10 can be used to modify the scale of the x-axis 
(and scale_y-functions used to modify the y-axis). In addition to log transforms, we can for instance control where the tick marks 
are located by using the breaks argument. If we only want to modify the tick marks (without doing a log transform), 
we can use **scale_x_continuous**:

```{r}
# Default:
ggplot(msleep, aes(brainwt, sleep_total, colour = vore)) + 
      geom_point() +
      labs(x = "Brain weight",
           y = "Total sleep time",
           colour = "Feeding behaviour")
```


```{r}
# Tick marks at all integers from 0 to 6:
ggplot(msleep, aes(brainwt, sleep_total, colour = vore)) + 
      geom_point() +
      labs(x = "Brain weight",
           y = "Total sleep time",
           colour = "Feeding behaviour") +
      scale_x_continuous(breaks = 0:6)
```


```{r}
# Tick mark at specific values:
ggplot(msleep, aes(brainwt, sleep_total, colour = vore)) + 
      geom_point() +
      labs(x = "Brain weight",
           y = "Total sleep time",
           colour = "Feeding behaviour") +
      scale_x_continuous(breaks = c(0, 2.5, 4.25))
```


### Using themes

ggplot2 comes with a number of basic themes. All are fairly similar but differ in things like background colour, grids, and borders.
You can add them to your plot using theme_themeName, where themeName is the name of the theme24. Here are some examples:

```{r}
p <- ggplot(msleep, aes(brainwt, sleep_total, colour = vore)) + 
      geom_point() +
      labs(x = "Brain weight (logarithmic scale)",
           y = "Total sleep time",
           colour = "Feeding behaviour") +
      scale_x_log10() +
      facet_wrap(~ vore)

# Create plot with different themes:
p + theme_grey() # The default theme
p + theme_bw()
p + theme_linedraw()
p + theme_light()
p + theme_dark()
p + theme_minimal()
p + theme_classic()
```


There are several packages available that contain additional themes. Let’s try a few:

```{r}
#install.packages("ggthemes")
library(ggthemes)

# Create plot with different themes from ggthemes:
p + theme_tufte() # Minimalist Tufte theme
p + theme_wsj() # Wall Street Journal
p + theme_solarized() + scale_colour_solarized() # Solarized colours
```


```{r}
#install.packages("hrbrthemes")
library(hrbrthemes)

# Create plot with different themes from hrbrthemes:
p + theme_ipsum() # Ipsum theme
p + theme_ft_rc() # Suitable for use with dark RStudio themes
p + theme_modern_rc() # Suitable for use with dark RStudio themes
```


###  Colour palettes

Unlike, e.g., background colours, the colour palette, i.e., the list of colours used for plotting, is not part of the theme that you’re using.
Next, we’ll have a look at how to change the colour palette used for your plot.

Let’s start by creating a ggplot object:

```{r}
p <- ggplot(msleep, aes(brainwt, sleep_total, colour = vore)) + 
      geom_point() +
      labs(x = "Brain weight (logarithmic scale)",
           y = "Total sleep time",
           colour = "Feeding behaviour") +
      scale_x_log10()
```

You can change the colour palette using scale_colour_brewer. Three types of colour palettes are available:

- **Sequential palettes**: these range from a colour to white. These are useful for representing ordinal 
(i.e., ordered) categorical variables and numerical variables.

- **Diverging palettes**: these range from one colour to another, with white in between. 
Diverging palettes are useful when there is a meaningful middle or 0 value 
(e.g., when your variables represent temperatures or profit/loss), which can be mapped to white.

- **Qualitative palettes**: these contain multiple distinct colours. They are useful for nominal (i.e., with no natural ordering) categorical variables.

See ?scale_colour_brewer or visit http://www.colorbrewer2.org for a list of the available palettes.
Here are some examples:

```{r}
# Sequential palette:
p + scale_colour_brewer(palette = "OrRd")
```


```{r}
# Diverging palette:
p + scale_colour_brewer(palette = "RdBu")
```


```{r}
# Qualitative palette:
p + scale_colour_brewer(palette = "Set1")
```

In this case, because vore is a nominal categorical variable, a qualitative palette is arguably the best choice.

In addition to these ready-made palettes, you can create your own custom palettes. 
...


###  Theme settings

The point of using a theme is that you get a combination of colours, fonts, and other choices that are supposed to go well together, 
meaning that you don’t have to spend too much time picking combinations. But if you like, you can override the default options 
and customise any and all parts of a theme.

The theme controls all visual aspects of the plot not related to the aesthetics. You can change the theme settings using the theme function. 
For instance, you can use theme to remove the legend or change its position:


```{r}
# No legend:
p + theme(legend.position = "none")

# Legend below figure:
p + theme(legend.position = "bottom")

# Legend inside plot:
p + theme(legend.position.inside = c(0.9, 0.7))
```

The base size of a theme controls the scale of the entire figure. This makes it useful when you want to rescale all elements of your plot at the same time:

```{r}
p + theme_grey(base_size = 8)
p + theme_grey(base_size = 20)
```
theme has a lot of other settings, including for the colours of the background, the grid, and the text in the plot. 
Here are a few examples that you can use as a starting point for experimenting with the settings:

```{r}
p + theme(panel.grid.major = element_line(colour = "black"),
          panel.grid.minor = element_line(colour = "purple",
                                          linetype = "dotted"),
          panel.background = element_rect(colour = "red", size = 2),
          plot.background = element_rect(fill = "lightgreen"),
          axis.text = element_text(family = "mono", colour = "blue"),
          axis.title = element_text(family = "serif", size = 14))
```


## 4.3 Exploring distributions

It is often useful to visualise the distribution of a numerical variable. Comparing the distributions of different groups can lead to important insights. 
Visualising distributions is also essential when checking assumptions used for various statistical tests (sometimes called initial data analysis). 
In this section, we will illustrate how this can be done using the *diamonds* data from the ggplot2 package. You can read more about it by running *?diamonds*.


### Density plots and frequency polygons

We already know how to visualise the distribution of the data by dividing it into bins and plotting a histogram:

```{r}
library(ggplot2)

ggplot(diamonds, aes(carat)) +
      geom_histogram(colour = "black")
```

A similar plot is created using frequency polygons, which uses lines instead of bars to display the counts in the bins:

```{r}
ggplot(diamonds, aes(carat)) +
      geom_freqpoly()
```

An advantage with frequency polygons is that they can be used to compare groups, e.g., diamonds with different cuts, without facetting:

```{r}
p <- ggplot(diamonds, aes(carat, colour = cut)) +
     geom_freqpoly()

# Legend below figure:
p # + theme(legend.position = "bottom")
```

It is clear from this figure that there are more diamonds with ideal cuts than diamonds with fair cuts in the data. 
The polygons have roughly the same shape, except perhaps for the polygon for diamonds with fair cuts.

In some cases, we are more interested in the shape of the distribution than in the actual counts in the different bins.
Density plots are similar to frequency polygons but show an estimate of the density function of the underlying random variable.
These estimates are smooth curves that are scaled so that the area below them is 1 (i.e., scaled to be proper density functions):

```{r}
ggplot(diamonds, aes(carat, colour = cut)) +
      geom_density()
```

From this figure, it becomes clear that low-carat diamonds tend to have better cuts, which wasn’t obvious from the frequency polygons. 
However, the plot does not provide any information about how common different cuts are. Use density plots if you’re more interested 
in the shape of a variable’s distribution, and frequency polygons if you’re more interested in counts.




**Exercise 4.2**

Using the density plot we just created above and the documentation for geom_density, do the following:

- Increase the smoothness of the density curves.

```{r}
ggplot(diamonds, aes(carat, colour = cut)) +
      geom_density(bw = 0.25)
```

- Fill the area under the density curves with the same colour as the curves themselves.

```{r}
ggplot(diamonds, aes(carat, colour = cut, fill = cut)) +
      geom_density(bw = 0.25)
```

- Make the colours that fill the areas under the curves transparent.

Because the densities overlap, it’d be better to make the fill colours slightly transparent. We add alpha to the geom:

```{r}
ggplot(diamonds, aes(carat, colour = cut, fill = cut)) +
      geom_density(bw = 0.2, alpha = 0.25)
```

- The figure still isn’t that easy to interpret. Install and load the ggridges package, an extension of ggplot2 that allows you to make so-called ridge plots
(density plots that are separated along the y-axis, similar to facetting). 
Read the documentation for geom_density_ridges and use it to make a ridge plot of diamond prices for different cuts.

A similar plot can be created using geom_density_ridges from the **ggridges** package. 
Note that you must set y = cut in the aes, because the densities should be separated by cut.

```{r}
if (!require(ggridges)) install.packages('ggridges', dependencies = T)
library(ggridges)

ggplot(diamonds, aes(carat, cut, fill = cut)) +
      geom_density_ridges()
```

**Exercise 4.3**

Return to the histogram created by ggplot(diamonds, aes(carat)) + geom_histogram() above. 
As there are very few diamonds with carat greater than 3, cut the x-axis at 3. 
Then decrease the bin width to 0.01. Do any interesting patterns emerge?

```{r}
ggplot(diamonds, aes(carat)) +
      geom_histogram(binwidth = 0.01) +
      xlim(0, 3)
```
It appears that carat values that are just above multiples of 0.25 are more common than other values. 
We’ll explore that next.


### Asking questions

Exercise 4.3 above causes us to ask why diamonds with carat values that are multiples of 0.25 are more common than others. 
Perhaps the price is involved? Unfortunately, a plot of carat versus price is not that informative:

```{r}
ggplot(data = diamonds, mapping = aes(carat, price)) +
      geom_point(size = 0.05)
```

Maybe we could compute the average price in each bin of the histogram? In that case, we need to extract the bin breaks from the histogram somehow. 
We could then create a new categorical variable using the breaks with cut (as we did in Exercise 2.27). 
It turns out that extracting the bins is much easier using base graphics than ggplot2, so let’s do that:

```{r}
# Extract information from a histogram with bin width 0.01, which corresponds to 481 breaks:
carat_br <- hist(diamonds$carat, breaks = 481, right = FALSE, plot = FALSE)

# Of interest to us are:
# carat_br$breaks, which contains the breaks for the bins
# carat_br$mid, which contains the midpoints of the bins (useful for plotting!)

# Create categories for each bin:
diamonds$carat_cat <- cut(diamonds$carat, 481, right = FALSE)
```

We now have a variable, carat_cat, that shows to which bin each observation belongs. Next, we’d like to compute the mean for each bin. 
This is a grouped summary – mean by category. After we’ve computed the bin means, we could then plot them against the bin midpoints. 
Let’s try it:

```{r}
means <- aggregate(price ~ carat_cat, data = diamonds, FUN = mean)

plot(carat_br$mid, means$price)

#That didn’t work as intended. We get an error message when attempting to plot the results:
```

By default, aggregate ignores groups for which there are no values when computing grouped summaries. 
In this case, there are a lot of empty bins – there is for instance no observation in the [4.99,5) bin. 
In fact, only 272 out of the 481 bins are non-empty.

We can solve this in different ways. One way is to remove the empty bins. We can do this using the match function, 
which returns the positions of matching values in two vectors. If we use it with the bins from the grouped summary and 
the vector containing all bins, we can find the indices of the non-empty bins. 
This requires the use of the **levels** function, which you’ll learn more about in Section 5.4:

```{r}
means <- aggregate(price ~ carat_cat, data = diamonds, FUN = mean)

id <- match(means$carat_cat, levels(diamonds$carat_cat))
```

Finally, we’ll also add some vertical lines to our plot, to call attention to multiples of 0.25.

Using base graphics is faster here:
```{r}
plot(carat_br$mid[id], means$price, cex = 0.5)

# Add vertical lines at multiples
# of 0.25:
abline(v = c(0.5, 0.75, 1, 1.25, 1.5))
```

But we can of course stick to ggplot2 if we like:
```{r}
library(ggplot2)

d2 <- data.frame(bin = carat_br$mid[id], mean = means$price)

ggplot(d2, aes(bin, mean)) +
       geom_point() +
       geom_vline(xintercept = c(0.5, 0.75, 1, 1.25, 1.5))
       # geom_vline add vertical lines at multiples of 0.25
```

It appears that there are small jumps in the prices at some of the 0.25-marks. 
This explains why there are more diamonds just above these marks than just below.

The above example illustrates three crucial things regarding exploratory data analysis:

- Plots (in our case, the histogram) often lead to new questions.

- Often, we must transform, summarise, or otherwise manipulate our data to answer a question.
Sometimes this is straightforward, and sometimes it means diving deep into R code.

- Sometimes the thing that we’re trying to do doesn’t work straight away. There is almost always a solution though 
(and oftentimes more than one!). The more you work with R, the more problem-solving tricks you will learn.


### Violin plots

Density curves can also be used as alternatives to boxplots. In Exercise 2.17, you created boxplots to visualise price differences between diamonds of different cuts:

```{r}
ggplot(diamonds, aes(cut, price)) +
      geom_boxplot()
```

Instead of using a boxplot, we can use a **violin plot**. Each group is represented by a “violin”, given by a rotated and duplicated density plot:

```{r}
ggplot(diamonds, aes(cut, price)) +
      geom_violin()
```

Compared to boxplots, violin plots capture the entire distribution of the data rather than just a few numerical summaries. 
If you like numerical summaries (and you should) you can add the median and the quartiles 
(corresponding to the borders of the box in the boxplot) using the draw_quantiles argument:

```{r}
ggplot(diamonds, aes(cut, price)) +
      geom_violin(draw_quantiles =  c(0.25, 0.5, 0.75))
```




**Exercise 4.4 **
Using the first boxplot created above, i.e., ggplot(diamonds, aes(cut, price)) + geom_violin(), do the following:

- Add some colour to the plot by giving different colours to each violin.

```{r}
ggplot(diamonds, aes(cut, price, fill = cut)) + 
  geom_violin()
```

- Because the categories are shown along the x-axis, we don’t really need the legend. Remove it.

```{r}
ggplot(diamonds, aes(cut, price, fill = cut)) + 
  geom_violin() +
  theme(legend.position = "none")
```

- Both boxplots and violin plots are useful. Maybe we can have the best of both worlds? Add the corresponding boxplot inside each violin. 
Hint: the width and alpha arguments in geom_boxplot are useful for creating a nice-looking figure here.

```{r}
ggplot(diamonds, aes(cut, price)) +
      geom_violin(aes(fill = cut), width = 1.25) +
      geom_boxplot(width = 0.1, alpha = 0.5) +
      theme(legend.position = "none")
```

- Flip the coordinate system to create horizontal violins and boxes instead.

```{r}
ggplot(diamonds, aes(cut, price)) +
      geom_violin(aes(fill = cut), width = 1.25) +
      geom_boxplot(width = 0.1, alpha = 0.5) +
      theme(legend.position = "none") +
      coord_flip()
```



## 4.4 Combining multiple plots into a single graphic

When exploring data with many variables, you’ll often want to make the same kind of plot (e.g., a violin plot) for several variables. 
It will frequently make sense to place these side-by-side in the same plot window. The patchwork package extends ggplot2 by letting you do just that.

Let’s install it: (at the beginning of the .Rmd)

And use it:

```{r}
plot1 <- ggplot(diamonds, aes(cut, carat, fill = cut)) +
            geom_violin() +
            theme(legend.position = "none")

plot2 <- ggplot(diamonds, aes(cut, price, fill = cut)) +
            geom_violin() +
            theme(legend.position = "none")

library(patchwork)
plot1 + plot2
```

You can also arrange the plots on multiple lines, with different numbers of plots on each line. 
This is particularly useful if you are combining different types of plots in a single plot window. 
In this case, you separate plots that are one the same line by | and mark the beginning of a new line with /:

```{r}
# Create two more plot objects:
plot3 <- ggplot(diamonds, aes(cut, depth, fill = cut)) +
            geom_violin() +
            theme(legend.position = "none")

plot4 <- ggplot(diamonds, aes(carat, fill = cut)) +
            geom_density(alpha = 0.5) +
            theme(legend.position = c(0.9, 0.6))

# One row with three plots and one row with a single plot:
(plot1 | plot2 | plot3) / plot4
```


```{r}
# One column with three plots and one column with a single plot:
(plot1 / plot2 / plot3) | plot4
```








