---
title: "05_Dealing_with_messy_data"
author: "Fran Camacho"
date: "2025-09-10"
output: word_document
---

# 5 - Dealing with messy data


…or, put differently, welcome to the real world. Real datasets are seldom as tidy and clean as those you have seen in the previous examples in this book.
On the contrary, real data is messy.
...

This chapter contains a number of examples that serve as cookbook recipes for common data wrangling tasks.
...


After working with the material in this chapter, you will be able to use R to:

- Handle numeric and categorical data,
- Manipulate and find patterns in text strings,
- Work with dates and times,
- Filter, subset, sort, and reshape your data using data.table, dplyr, and tidyr,
. Split and merge datasets,
. Scrape data from the web, and
. Import data from different file formats.


```{r}
#Libraries

#https://tidyverse.r-universe.dev/tidyverse
if (!require(tidyverse)) install.packages('tidyverse', repos = c('https://tidyverse.r-universe.dev', 'https://cloud.r-project.org'))
library(tidyverse)


```


## 5.1 Changing data types

In Exercise 2.21 you discovered that R implicitly coerces variables into other data types when needed. 
For instance, if you add a numeric to a logical, the result is a numeric.
And if you place them together in a vector, the vector will contain two numeric values:

```{r}
TRUE + 5   ## TRUE == 1
v1 <- c(TRUE, 5)
v1
```

However, if you add a numeric to a character, the operation fails. 
And if you put them together in a vector, both become character strings:

```{r}
"One" + 5
```


```{r}
v2 <- c("One", 5)
v2
```

There is a hierarchy for data types in R: logical < integer < numeric < character. When variables of different types are somehow combined 
(with addition, put in the same vector, and so on), R will coerce both to the higher ranking type.
That is why v1 contained numeric variables ..

Automatic coercion is often useful, but will sometimes cause problems. As an example, a vector of numbers may accidentally be converted 
to a character vector, which will confuse plotting functions. Luckily it is possible to convert objects to other data types. 
The functions most commonly used for this are **as.logical**, **as.numeric** and **as.character**. Here are some examples of how they can be used:

```{r}
as.logical(1)           # Should be TRUE
as.logical("FALSE")     # Should be FALSE
as.numeric(TRUE)        # Should be 1
as.numeric("2.718282")  # Should be numeric 2.718282
as.character(2.718282)  # Should be the string "2.718282"
as.character(TRUE)      # Should be the string "TRUE"
```

A word of warning though – conversion only works if R can find a natural conversion between the types.
Here are some examples where conversion fails. Note that only some of them cause warning messages:

```{r}
as.numeric("two")                   # Should be 2
as.numeric("1+1")                   # Should be 2 <- should be?
as.numeric("2,718282")              # Should be numeric 2.718282
as.logical("Vaccines cause autism") # Should be FALSE
```




**Exercise 5.1**
The following tasks are concerned with converting and checking data types:

- What happens if you apply as.logical to the numeric values 0 and 1? What happens if you apply it to other numbers?

```{r}
as.logical(0) # FALSE
as.logical(1) # TRUE
as.logical(123)  # TRUE
```

- What happens if you apply as.character to a vector containing numeric values?

```{r}
as.character(c(1,2,3,pi,sqrt(22))) # all converted
```

- The functions is.logical, is.numeric and is.character can be used to check if a variable is a logical, numeric or character, respectively. 
What type of object do they return?

```{r}
is.numeric(123)
is.numeric("123")

```

- Is NA a logical, numeric or character?

```{r}
is.logical(NA)
is.numeric(NA) 
is.character(NA)
```

?NA  -> "ºNA is a logical constant of length 1 which contains a missing value indicator. ..."


## 5.2 Working with lists

A data structure that is very convenient for storing data of different types is list. You can think of a list as a data frame
where you can put different types of objects in each column: like a numeric vector of length 5 in the first, a data frame in the second,
and a single character in the third. 
Here is an example of how to create a list using the function of the same name:

```{r}
my_list <- list(my_numbers = c(86, 42, 57, 61, 22),
                my_data = data.frame(a = 1:3, b = 4:6),
                my_text = "Lists are the best.")

my_list
```

To access the elements in the list, we can use the same $ notation as for data frames:

```{r}
my_list$my_numbers
my_list$my_text
my_list$my_data$a[3]
```

In addition, we can access them using indices, but using double brackets:

```{r}
my_list[[1]]
#my_list[[2]]
my_list[[3]]
```

To access elements within the elements of lists, additional brackets can be added.
For instance, if you wish to access the second element of the my_numbers vector, you can use either of these:

```{r}
my_list[[1]][2]
my_list$my_numbers[2]
```


### Splitting vectors into lists

Consider the airquality dataset, which among other things describes the temperature on each day during a five-month period.
Suppose that we wish to split the airquality$Temp vector into five separate vectors: one for each month.
We could do this by repeated filtering, e.g.,

```{r}
temp_may <- airquality$Temp[airquality$Month == 5]
temp_june <- airquality$Temp[airquality$Month == 6]
# ...and so on.
```

Apart from the fact that this isn’t a very good-looking solution, this would be infeasible if we needed to split our vector 
into a larger number of new vectors. Fortunately, there is a function that allows us to split the vector by month,
storing the result as a list - **split**:

```{r}
temps <- split(airquality$Temp, airquality$Month)
temps
```


```{r}
# To access the temperatures for June:
temps$`6`
temps[[2]]
```


```{r}
# To give more informative names to the elements in the list:
names(temps) <- c("May", "June", "July", "August", "September")
temps$June
```

Note that, in breach of the rules for variable names in R, the original variable names here were numbers 
(actually character variables that happened to contain numeric characters). 
When accessing them using $ notation, you need to put them between backticks (`), e.g., temps$`6`, 
to make it clear that 6 is a variable name and not a number.


### Collapsing lists into vectors

Conversely, there are times where you want to collapse a list into a vector. This can be done using **unlist**:

```{r}
original <- unlist(temps)
original
```


**Exercise 5.2**
Load the vas.csv data from Exercise 2.30. Split the VAS vector so that you get a list containing one vector for each patient. 
How can you then access the visual analogue scale (VAS) values for patient 212?

```{r}
vas <- read.csv("vas.csv", sep = ";", dec = ",", skip = 4)
```

```{r}
vas_split <- split(vas$VAS, vas$ID)

vas_split$`212`
vas_split[[12]]
```


## 5.3 Working with numbers

A lot of data analyses involve numbers, which typically are represented as **numeric** values in R.
..

### Rounding numbers

At times you may want to round numbers, either for presentation purposes or for some other reason.
There are several functions that can be used for this:

```{r}
a <- c(2.1241, 3.86234, 4.5, -4.5, 10000.1001)

round(a, 3)           # Rounds to 3 decimal places
signif(a, 3)          # Rounds to 3 significant digits
```


```{r}
ceiling(a)            # Rounds up to the nearest integer
floor(a)              # Rounds down to the nearest integer

trunc(a)              # Rounds to the nearest integer, toward 0
                      # (note the difference in how 4.5
                      #  and -4.5 are treated!)
```


### Sums and means in data frames

When working with numerical data, you’ll frequently find yourself wanting to compute sums or means of either columns or rows of data frames. 
The **colSums, rowSums, colMeans and rowMeans** functions can be used to do this. Here is an example with an expanded version of the bookstore data, 
where three purchases have been recorded for each customer:

```{r}
bookstore2 <- data.frame(purchase1 = c(20, 59, 2, 12, 22, 160,
                                       34, 34, 29),
                         purchase2 = c(14, 67, 9, 20, 20, 81,
                                       19, 55, 8),
                         purchase3 = c(4, 62, 11, 18, 33, 57,
                                       24, 49, 29))
bookstore2
```


```{r}
colSums(bookstore2)   # The total amount for customers' 1st, 2nd and 3rd purchases
rowSums(bookstore2)   # The total amount for each customer
colMeans(bookstore2)  # Mean purchase for 1st, 2nd and 3rd purchases
rowMeans(bookstore2)  # Mean purchase for each customer
```

Moving beyond sums and means, in Section 6.5 you’ll learn how to apply any function to the rows or columns of a data frame.


### Summaries of series of numbers

When a numeric vector contains a series of consecutive measurements, as is the case, e.g., in a time series, it is often of interest
to compute various cumulative summaries. For instance, if the vector contains the daily revenue of a business during a month, 
it may be of value to know the total revenue up to each day, that is, the cumulative sum for each day.

Let’s return to the **a10** data from Section 4.7, which described the monthly anti-diabetic drug sales in Australia during 1991-2008.

```{r}
library(fpp2)
a10
```

Elements 7 to 18 contain the sales for 1992. We can compute the total, highest, and smallest monthly sales up to and including each month
**using cumsum, cummax, and cummin**:

```{r}
#a10[7:18]
cumsum(a10[7:18])  # Total sales
cummax(a10[7:18])  # Highest monthly sales
cummin(a10[7:18])  # Lowest monthly sales
```


```{r}
# Plot total sales up to and including each month:
plot(1:12, cumsum(a10[7:18]),
     xlab = "Month",
     ylab = "Total sales",
     type = "b")
```

In addition, the cumprod function can be used to compute cumulative products.

At other times, we are interested in studying run lengths in series, that is, the lengths of runs of equal values in a vector. 
Consider the upp_temp vector defined in the code chunk below, which contains the daily temperatures in Uppsala, Sweden, in February 2020.

```{r}
upp_temp <- c(5.3, 3.2, -1.4, -3.4, -0.6, -0.6, -0.8, 2.7, 4.2, 5.7,
              3.1, 2.3, -0.6, -1.3, 2.9, 6.9, 6.2, 6.3, 3.2, 0.6, 5.5,
              6.1, 4.4, 1.0, -0.4, -0.5, -1.5, -1.2, 0.6)
```


It could be interesting to look at runs of sub-zero days, i.e., consecutive days with sub-zero temperatures.
The **rle** function counts the lengths of runs of equal values in a vector. To find the length of runs of temperatures below or above zero
we can use the vector defined by the condition upp_temp < 0, the values of which are TRUE on sub-zero days and FALSE when the temperature is 0 or higher.
When we apply rle to this vector, it returns the length and value of the runs:

```{r}
rle(upp_temp < 0)
```

We first have a 2-day run of above zero temperatures (FALSE), then a 5-day run of sub-zero temperatures (TRUE), then a 5-day run of above zero temperatures, and so on.


### Scientific notation: 1e-03

When printing very large or very small numbers, R uses scientific notation, meaning that 7,000,000 (7 followed by 6 zeroes) is displayed as
(the mathematically equivalent) 7⋅106, and 0.0000007 is displayed as 7⋅10−7. Well, almost, the 10 raised to the power of x bit isn’t really displayed as 10x,
but as e+x, a notation used in many programming languages and calculators. 
Here are some examples:

```{r}
7000000
0.0000007
7e+07
exp(30)
```

Scientific notation is a convenient way to display very large and very small numbers, but it’s not always desirable.
If you just want to print the number, the format function can be used to convert it to a character, suppressing scientific notation:

```{r}
format(7000000)
format(7000000, scientific = FALSE)
```

If you still want your number to be a numeric (as you often do), a better choice is to change the option for when R uses scientific notation.
This can be done using the scipen argument in the options function:

```{r}
options(scipen = 1000)

7000000
0.0000007
7e+07
exp(30)
```

To revert this option back to the default, you can use:

```{r}
options(scipen = 0)

7000000
0.0000007
7e+07
exp(30)
```

Note that this option only affects how R prints numbers, and not how they are treated in computations.


### Floating point arithmetics

Some numbers cannot be written in finite decimal forms. Take 1/3 for example, the decimal form of which is 0.33333333333333333333333333333333….

Clearly, the computer cannot store this number exactly, as that would require an infinite memory. Because of this, numbers in computers are stored 
as floating point numbers, which aim to strike a balance between range (being able to store both very small and very large numbers) 
and precision (being able to represent numbers accurately). 
Most of the time, calculations with floating points yield exactly the results that we’d expect, but sometimes these non-exact representations 
of numbers will cause unexpected problems. If we wish to compute 1.5−0.2 and 1.1−0.2, say, we could of course use R for that.
Let’s see if it gets the answers right:

```{r}
1.5 - 0.2
1.5 - 0.2 == 1.3  # Check if 1.5-0.2=1.3
```


```{r}
1.1 - 0.2
1.1 - 0.2 == 0.9  # Check if 1.1-0.2=0.9
```

The limitations of floating point arithmetics cause the second calculation to fail. To see what has happened, 
we can use sprintf to print numbers with 30 decimals (by default, R prints a rounded version with fewer decimals):

```{r}
sprintf("%.30f", 1.1 - 0.2)
sprintf("%.30f", 0.9)
```

The first 12 decimals are identical, but after that the two numbers 1.1 - 0.2 and 0.9 diverge. 
In our other example, 1.5−0.2, we don’t encounter this problem – both 1.5 - 0.2 and 0.3 have the same floating point representation:

```{r}
sprintf("%.30f", 1.5 - 0.2)
sprintf("%.30f", 1.3)
```

The order of the operations also matters in this case. The following three calculations would all yield identical results 
if performed with real numbers, but in floating point arithmetics the results differ:

```{r}
1.1 - 0.2 - 0.9
1.1 - 0.9 - 0.2
1.1 - (0.9 + 0.2)
```


In most cases, it won’t make a difference whether a variable is represented as 0.90000000000000013… or 0.90000000000000002…, 
but in some cases tiny differences like that can propagate and cause massive problems. A famous example of this involves
the US Patriot surface-to-air defence system, which at the end of the first Gulf War missed an incoming missile due to an error in floating point arithmetics. 
It is important to be aware of the fact that floating point arithmetics occasionally will yield incorrect results. 
This can happen for numbers of any size, but it is more likely to occur when very large and very small numbers appear in the same computation.

So, 1.1 - 0.2 and 0.9 may not be the same thing in floating point arithmetics, but at least they are nearly the same thing. 
The == operator checks if two numbers are exactly equal, but there is an alternative that can be used to check if two numbers are nearly equal: **all.equal**. 
If the two numbers are (nearly) equal, it returns TRUE, and if they are not, it returns a description of how they differ. 
In order to avoid the latter, we can use the **isTRUE** function to return FALSE instead:

```{r}
1.1 - 0.2 == 0.9
all.equal(1.1 - 0.2, 0.9)
all.equal(1, 2)
isTRUE(all.equal(1, 2))
isTRUE(all.equal(0.1, 1.1 - 0.2 - 0.8))
```




**Exercise 5.3**
These tasks showcase some problems that are commonly faced when working with numeric data:

- The vector props <- c(0.1010, 0.2546, 0.6009, 0.0400, 0.0035) contains proportions (which, by definition, are between 0 and 1). Convert the proportions to percentages with one decimal place.

```{r}
props <- c(0.1010, 0.2546, 0.6009, 0.0400, 0.0035)
round(100 * props, 1)
```

- Compute the highest and lowest temperatures up to and including each day in the airquality dataset.

```{r}
cummax(airquality$Temp)
cummin(airquality$Temp)
```
 
The minimum during the period occurs on the 5th day (56), whereas the maximum occurs during day 120 (97).

- What is the longest run of days with temperatures above 80 in the airquality dataset?

```{r}
runs <- rle(airquality$Temp > 80)

runs$lengths[runs$values == TRUE]
```

We see that the longest run was 23 days.


**Exercise 5.4**
These tasks are concerned with floating point arithmetics:

- Very large numbers, like 10e500, are represented by Inf (infinity) in R. Try to find out what the largest number that can be represented as a floating point number in R is.

"On virtually all systems, the largest number that R can represent as a floating point is 1.797693e+308. You can find this by gradually trying larger and larger numbers:"

```{r}
1e+100
1e+200
1e+300

1e+305

1e+308
100e+308
1e+309

1e+500
1e+1000
```


- Due to an error in floating point arithmetics, sqrt(2)^2 - 2 is not equal to 0. Change the order of the operations so that the results is 0.

```{r}
sqrt(2)^2 - 2  # Not 0
sqrt(2^2) - 2  # 0
```


## 5.4 Working with categorical data and factors

In Sections 2.6.2 and 2.8 we looked at how to analyse and visualise categorical data, i.e., data where the variables can take 
a fixed number of possible values that somehow correspond to groups or categories. But so far we haven’t really gone into
how to handle categorical variables in R.

Categorical data is stored in R as factor variables. You may ask why a special data structure is needed for categorical data,
when we could just use character variables to represent the categories. Indeed, the latter is what R does by default, e.g., 
when creating a data.frame object or reading data from .csv and .xlsx files.

Let’s say that you’ve conducted a survey on students’ smoking habits. The possible responses are Never, Occasionally, Regularly, 
and Heavy. From 10 students, you get the following responses:

```{r}
smoke <- c("Never", "Never", "Heavy", "Never", "Occasionally",
           "Never", "Never", "Regularly", "Regularly", "No")
```

Note that the last answer is invalid – No was not one of the four answers that were allowed for the question.

You could use table to get a summary of how many answers of each type that you got:

```{r}
table(smoke)
```

But the categories are not presented in the correct order! There is a clear order between the different categories,
Never < Occasionally < Regularly < Heavy, but table doesn’t present the results in that way.
Moreover, R didn’t recognise that No was an invalid answer and treats it just the same as the other categories.

This is where factor variables come in. They allow you to specify which values your variable can take, and the ordering between them (if any).

### Creating factors

When creating a factor variable, you typically start with a character, numeric or logical variable, the values of which are turned into categories.
To turn the smoke vector that you created in the previous section into a factor, you can use the factor function:

```{r}
smoke2 <- factor(smoke)

smoke2
```

So far, we haven’t solved neither the problem of the categories being in the wrong order nor that invalid No value. 
To fix both these problems, we can use the **levels** argument in factor:

```{r}
smoke3 <- factor(smoke, levels = c("Never", "Occasionally", "Regularly", "Heavy"),
                        ordered = TRUE)

# Check the results:
smoke3
levels(smoke3)
table(smoke3)
```

You can control the order in which the levels are presented by choosing which order we write them in the levels argument. 
The ordered = TRUE argument specifies that the order of the variables is meaningful.
...
To find the values of smoke that became NA in smoke2, you can use which and is.na:

```{r}
smoke[which(is.na(smoke3))]
```



By checking the original values of the NA elements, you can see if they should be excluded from the analysis or recoded into a proper category
(No could for instance be recoded into Never). In Section 5.5.3 you’ll learn how to replace values in larger datasets automatically using regular expressions.


### Changing factor levels

When we created smoke3, one of the elements became an NA. NA was however not included as a level of the factor.
Sometimes, it is desirable to include NA as a level, for instance when you want to analyse rows with missing data.
This is easily done using the **addNA** function:

```{r}
smoke3 <- addNA(smoke3)

smoke3
```

If you wish to change the name of one or more of the factor levels, you can do it directly via the levels function.
For instance, we can change the name of the NA category, which is the 5th level of smoke2, as follows:

```{r}
levels(smoke3)[5] <- "Invalid answer"

smoke3
table(smoke3)
```

The above solution is a little brittle in that it relies on specifying the index of the level name, which can change if we’re not careful.
More robust solutions using the data.table and dplyr packages are presented in Section 5.7.6.

Finally, if you’ve added more levels than what are actually used, these can be dropped using the **droplevels** function:

```{r}
smoke4 <- factor(smoke, levels = c("Never", "Occasionally", "Regularly", "Heavy", "Constantly"),
                        ordered = TRUE)

levels(smoke4)
smoke4 <- droplevels(smoke4)

levels(smoke4)
```


### Changing the order of levels

Now suppose that we’d like the levels of the smoke variable to be presented in the reverse order: Heavy, Regularly, Occasionally, and Never.
This can be done by a new call to factor, where the new level order is specified in the levels argument:

```{r}
smoke5 <- factor(smoke4, levels = c("Heavy", "Regularly", "Occasionally", "Never"))

# Check the results:
levels(smoke5)
```


### Combining levels

Finally, levels can be used to merge categories by replacing their separate names with a single name. 
For instance, we can combine the smoking categories Occasionally, Regularly, and Heavy to a single category named Yes.
Assuming that these are first, second, and third in the list of names (as will be the case if you’ve run the last code chunk above), 
here’s how to do it:

```{r}
levels(smoke5)[1:3] <- "Yes"

# Check the results:
levels(smoke5)
```




**Exercise 5.5**
In Exercise 2.27 you learned how to create a factor variable from a numeric variable using cut. 
Return to your solution (or the solution at the back of the book) and do the following:

- Change the category names to Mild, Moderate, and Hot.

We re-use the solution from Exercise 2.27:

```{r}
airquality$TempCat <- cut(airquality$Temp,
                          breaks = c(50, 70, 90, 110))
```

Next, we change the levels’ names:

```{r}
#airquality$TempCat  # [1] (50,70]  (70,90]  (70,90]  (50,70]  (50,70] ...

levels(airquality$TempCat) <- c("Mild", "Moderate", "Hot")

#airquality$TempCat  # [1] Mild     Moderate Moderate Mild  Mild ...
```

- Combine Moderate and Hot into a single level named Hot.

```{r}
levels(airquality$TempCat)[2:3] <- "Hot"

#airquality$TempCat  # [1] Mild Hot  Hot  Mild Mild ...
```


**Exercise 5.6** 
Load the msleep data from the ggplot2 package. Note that categorical variable vore is stored as a character. 
Convert it to a factor by running msleep$vore <- factor(msleep$vore).

```{r}
library(ggplot2)
str(msleep) # vore is a character vector!
```

- How are the resulting factor levels ordered? Why are they ordered in that way?

```{r}
msleep$vore <- factor(msleep$vore)
levels(msleep$vore)
```

The levels are ordered alphabetically, which is the default in R.

- Compute the mean value of sleep_total for each vore group.

To compute grouped means, we use aggregate:

```{r}
means <- aggregate(sleep_total ~ vore, data = msleep, FUN = mean)

means
```


- Sort the factor levels according to their sleep_total means.
Hint: this can be done manually, or more elegantly using, e.g., a combination of the functions rank and match in an intermediate step.

```{r}
# Check order:
#means
# New order: herbi, carni, omni, insecti.

# We could set the new order manually:
msleep$vore <- factor(msleep$vore,
                      levels = c("herbi", "carni", "omni", "insecti"))
```


```{r}
# Alternatively, rank and match can be used to get the new order of
# the levels:
?rank
?match
ranks <- rank(means$sleep_total)
new_order <- match(1:4, ranks)

msleep$vore <- factor(msleep$vore,
                      levels = levels(msleep$vore)[new_order])
```


## Working with strings

Text in R is represented by character strings. These are created using double or single quotes. I recommend double quotes for three reasons.
First, it is the default in R and is the recommended style (see, e.g., ?Quotes). 
Second, it improves readability – code with double quotes is easier to read because double quotes are easier to spot than single quotes. 
Third, it will allow you to easily use apostrophes in your strings, which single quotes don’t (because apostrophes will be interpreted as the end of the string).
Single quotes can however be used if you need to include double quotes inside your string:

```{r}
# This works:
text1 <- "An example of a string. Isn't this great?"
text2 <- 'Another example of a so-called "string".'

# This doesn't work:
#text1_fail <- 'An example of a string. Isn't this great?'
#text2_fail <- "Another example of a so-called "string"."
```

If you check what these two strings look like, you’ll notice something funny about text2:

```{r}
text1
text2
```

R has put backslash characters, \, before the double quotes. The backslash is called an escape character, 
which invokes a different interpretation of the character that follows it. 
In fact, you can use this to put double quotes inside a string that you define using double quotes:

```{r}
text2_success <- "Another example of a so-called \"string\"."

text2_success
```

There are a number of other special characters that can be included using a backslash: 
\n for a line break (a new line) and \t for a tab (a long whitespace) being the most important:

```{r}
text3 <- "Text... \n \t With indented text on a new line!"

text3
```

(What?)

To print your string in the Console in a way that shows special characters instead of their escape character-versions, use the function cat:

```{r}
cat(text3)
```

(Ah,)

You can also use cat to print the string to a text file…

```{r}
# cat(text3, file = "new_findings.txt")
```

... and to append text at the end of a text file:

```{r}
cat("Let's add even more text!", file = "new_findings.txt", append = TRUE)
```


### Concatenating strings

If you wish to concatenate multiple strings, cat will do that for you:

```{r}
first <- "This is the beginning of a sentence"
second <- "and this is the end."

cat(first, second)
```

By default, cat places a single white space between the two strings, ...
. You can change that using the **sep** argument in cat. You can also add as many strings as you like as input:

```{r}
cat(first, second, sep = "; ")
cat(first, second, sep = "\n")
cat(first, second, sep = "")
cat(first, second, "\n", "And this is another sentence.")
```

At other times, you want to concatenate two or more strings without printing them.
You can then use paste in exactly the same way as you’d use cat, the exception being that paste returns a string instead of printing it.

```{r}
my_sentence <- paste(first, second, sep = "; ")
my_novel <- paste(first, second, "\n", "And this is another sentence.")

# View results:
my_sentence
my_novel
cat(my_novel)
```

Finally, if you wish to create a number of similar strings based on information from other variables,
you can use **sprintf**, which allows you to write a string using **%s** as a placeholder for the values that should be pulled
from other variables:

```{r}
names <- c("Irma", "Bea", "Lisa")
ages <- c(5, 59, 36)

sprintf("%s is %s years old.", names, ages)
```


### Changing case

If you need to translate characters from lowercase to uppercase or vice versa, that can be done using toupper and tolower:

```{r}
my_string <- "SOMETIMES I SCREAM (and sometimes I whisper)."

toupper(my_string)
tolower(my_string)
```


If you only wish to change the case of some particular element in your string, you can use **substr**, which allows you to access substrings:

```{r}
months <- c("january", "february", "march", "aripl")

# Replacing characters 2-4 of months[4] with "pri":
substr(months[4], 2, 4) <- "pri"
months

# Replacing characters 1-1 (i.e. character 1) of each element of month
# with its uppercase version:
substr(months, 1, 1) <- toupper(substr(months, 1, 1))
months
```


### Finding patterns using regular expressions

...

To illustrate the use of regular expressions, we will use a sheet from the projects-email.xlsx file from the book’s web page.
In Exercise 2.32, you explored the second sheet in this file, but here we’ll use the third instead. 
Set file_path to the path to the file, and then run the following code to import the data:

```{r}
if (!require(openxlsx)) install.packages('openxlsx', dependencies = T)
library(openxlsx)
```

```{r}
library(openxlsx)

contacts <- read.xlsx("data/projects-email.xlsx", sheet = 3)
str(contacts)
```

There are now three variables in contacts. We’ll primarily be concerned with the third one: Address. 
Some people have email addresses attached to them, others have postal addresses, and some have no address at all:

```{r}
contacts$Address
```

You can find loads of guides on regular expressions online, but few of them are easy to use with R, the reason being that regular expressions in R
sometimes require escape characters that aren’t needed in some other programming languages. 
In this section we’ll take a look at regular expressions, *as they are written in R*.

The basic building blocks of regular expressions are patterns consisting of one or more characters. If, for instance, we wish to find all occurrences 
of the letter y in a vector of strings, the regular expression describing that “pattern” is simply "y". 
The functions used to find occurrences of patterns are called **grep** and **grepl**. They differ only in the output they return: 
grep returns the indices of the strings containing the pattern, and 
grepl returns a logical vector with TRUE at indices matching the patterns and FALSE at other indices.

To find all addresses containing a lowercase y, we use grep and grepl as follows:

```{r}
grep("y", contacts$Address)
grepl("y", contacts$Address)
```

Note how both outputs contain the same information presented in different ways.

In the same way, we can look for word or substrings. For instance, we can find all addresses containing the string "Edin":

```{r}
grep("Edin", contacts$Address)
grepl("Edin", contacts$Address)
```

Similarly, we can also look for special characters. Perhaps we can find all email addresses by looking for strings containing the @ symbol:

```{r}
grep("@", contacts$Address)
grepl("@", contacts$Address)
```

To display the addresses matching the pattern:

```{r}
# 
contacts$Address[grep("@", contacts$Address)]
```

...

Patterns describing classes of characters, e.g., characters with certain properties, are denoted by brackets [] (for manually defined classes)
or double brackets [[]] (for pre-defined classes). One example of the latter is "[[:digit:]], which is a pattern that matches all digits: 0 1 2 3 4 5 6 7 8 9. 
Let’s use it to find all addresses containing a number:

```{r}
grep("[[:digit:]]", contacts$Address)
```


```{r}
contacts$Address[grep("[[:digit:]]", contacts$Address)]
```


Some important pre-defined classes are:

    [[:lower:]] matches lowercase letters,
    [[:upper:]] matches UPPERCASE letters,
    [[:alpha:]] matches both lowercase and UPPERCASE letters,
    [[:digit:]] matches digits: 0 1 2 3 4 5 6 7 8 9,
    [[:alnum:]] matches alphanumeric characters (alphabetic characters and digits),
    [[:punct:]] matches punctuation characters: ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ { | } ~`,
    [[:space:]] matches space characters: space, tab, newline, and so on,
    [[:graph:]] matches letters, digits, and punctuation characters,
    [[:print:]] matches letters, digits, punctuation characters, and space characters,
    . matches any character.

Examples of manually defined classes are:

    [abcd] matches a, b, c, and d,
    [a-d] matches a, b, c, and d,
    [aA12] matches a, A, 1 and 2,
    [.] matches .,
    [.,] matches . and ,,
    [^abcd] matches anything except a, b, c, or d.


So, for instance, we can find all addresses that don’t contain at least one of the letters y and z using:

```{r}
grep("[^yz]", contacts$Address)
```


```{r}
contacts$Address[grep("[^yz]", contacts$Address)]
```

!!!!

[1] "ashlyn.cortes(a)r-project.org"     <- it DOES contain y
[21] "tracey.best@r-project.org"        <- ALSO!
[28] "sam.diaz@r-project.org"           <- it contains z ...  

???


All of these patterns can be combined with patterns describing a single character:

    gr[ea]y matches grey and gray (but not greay!),
    b[^o]g matches bag, beg, and similar strings, but not bog,
    [.]com matches .com.

When using the patterns above, you only look for a single occurrence of the pattern. Sometimes you may want a pattern like a word of 2-4 letters or any number of digits in a row. To create these, you add repetition patterns to your regular expression:

    ? means that the preceding pattern is matched at most once, i.e., 0 or 1 time,
    * means that the preceding pattern is matched 0 or more times,
    + means that the preceding pattern is matched at least once, i.e., 1 time or more,
    {n} means that the preceding pattern is matched exactly n times,
    {n,} means that the preceding pattern is matched at least n times, i.e., n times or more,
    {n,m} means that the preceding pattern is matched at least n times but not more than m times.

Here are some examples of how repetition patterns can be used:

```{r}
# There are multiple ways of finding strings containing two n's
# in a row:
contacts$Address[grep("nn", contacts$Address)]
contacts$Address[grep("n{2}", contacts$Address)]
```


```{r}
# Find strings with words beginning with an uppercase letter, followed
# by at least one lowercase letter:
contacts$Address[grep("[[:upper:]][[:lower:]]+", contacts$Address)]
```


```{r}
# Find strings with words beginning with an uppercase letter, followed
# by at least six lowercase letters:
contacts$Address[grep("[[:upper:]][[:lower:]]{6,}", contacts$Address)]
```


```{r}
# Find strings containing any number of letters, followed by any
# number of digits, followed by a space:
contacts$Address[grep("[[:alpha:]]+[[:digit:]]+[[:space:]]",
                      contacts$Address)]
```

Finally, there are some other operators that you can use to create even more complex patterns:

    | alteration, picks one of multiple possible patterns. For example, ab|bc matches ab or bc.
    () parentheses are used to denote a subset of an expression that should be evaluated separately. For example, colo|our matches colo or our while col(o|ou)r matches color or colour.
    ^, when used outside of brackets [], means that the match should be found at the start of the string. For example, ^a matches strings beginning with a, but not "dad".
    $ means that the match should be found at the end of the string. For example, a$ matches strings ending with a, but not "dad".
    \\ escape character that can be used to match special characters like ., ^ and $ (\\., \\^, \\$).

This may seem like a lot (and it is!), but there are in fact many more possibilities when working with regular expression. For the sake of some sort of brevity, we’ll leave it at this for now though.

Let’s return to those email addresses. We saw three regular expressions that could be used to find them:

```{r}
grep(".+@.+[.].+", contacts$Address)
grep(".+@.+\\..+", contacts$Address)

grep("[[:graph:]]+@[[:graph:]]+[.][[:alpha:]]+", contacts$Address)
grep("[[:alnum:]._-]+@[[:alnum:]._-]+[.][[:alpha:]]+", contacts$Address)
```

The first two of these specify the same pattern: any number of any characters, followed by an @, followed by any number of any characters, followed by a period ., 
followed by any number of characters. This will match email addresses but would also match strings like "?=)(/x@!.a??", which isn’t a valid email address.
In this case, that’s not a big issue, as our goal was to find addresses that looked like email addresses and not to verify that the addresses were valid.

The third alternative has a slightly different pattern: any number of letters, digits, and punctuation characters, followed by an @, followed by any number of letters,
digits, and punctuation characters, followed by a period ., followed by any number of letters. This too would match "?=)(/x@!.a??" as it allows 
punctuation characters that don’t usually occur in email addresses. The fourth alternative, however, won’t match "?=)(/x@!.a??" as it only allows letters, 
digits and the symbols ., _ and - in the name and domain name of the address.



