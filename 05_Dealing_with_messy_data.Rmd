---
title: "05_Dealing_with_messy_data"
author: "Fran Camacho"
date: "2025-09-10"
output: word_document
---

# 5 - Dealing with messy data


…or, put differently, welcome to the real world. Real datasets are seldom as tidy and clean as those you have seen in the previous examples in this book.
On the contrary, real data is messy.
...

This chapter contains a number of examples that serve as cookbook recipes for common data wrangling tasks.
...


After working with the material in this chapter, you will be able to use R to:

- Handle numeric and categorical data,
- Manipulate and find patterns in text strings,
- Work with dates and times,
- Filter, subset, sort, and reshape your data using data.table, dplyr, and tidyr,
. Split and merge datasets,
. Scrape data from the web, and
. Import data from different file formats.


```{r}
#Libraries

#https://tidyverse.r-universe.dev/tidyverse
if (!require(tidyverse)) install.packages('tidyverse', repos = c('https://tidyverse.r-universe.dev', 'https://cloud.r-project.org'))
library(tidyverse)


```


## 5.1 Changing data types

In Exercise 2.21 you discovered that R implicitly coerces variables into other data types when needed. 
For instance, if you add a numeric to a logical, the result is a numeric.
And if you place them together in a vector, the vector will contain two numeric values:

```{r}
TRUE + 5   ## TRUE == 1
v1 <- c(TRUE, 5)
v1
```

However, if you add a numeric to a character, the operation fails. 
And if you put them together in a vector, both become character strings:

```{r}
"One" + 5
```


```{r}
v2 <- c("One", 5)
v2
```

There is a hierarchy for data types in R: logical < integer < numeric < character. When variables of different types are somehow combined 
(with addition, put in the same vector, and so on), R will coerce both to the higher ranking type.
That is why v1 contained numeric variables ..

Automatic coercion is often useful, but will sometimes cause problems. As an example, a vector of numbers may accidentally be converted 
to a character vector, which will confuse plotting functions. Luckily it is possible to convert objects to other data types. 
The functions most commonly used for this are **as.logical**, **as.numeric** and **as.character**. Here are some examples of how they can be used:

```{r}
as.logical(1)           # Should be TRUE
as.logical("FALSE")     # Should be FALSE
as.numeric(TRUE)        # Should be 1
as.numeric("2.718282")  # Should be numeric 2.718282
as.character(2.718282)  # Should be the string "2.718282"
as.character(TRUE)      # Should be the string "TRUE"
```

A word of warning though – conversion only works if R can find a natural conversion between the types.
Here are some examples where conversion fails. Note that only some of them cause warning messages:

```{r}
as.numeric("two")                   # Should be 2
as.numeric("1+1")                   # Should be 2 <- should be?
as.numeric("2,718282")              # Should be numeric 2.718282
as.logical("Vaccines cause autism") # Should be FALSE
```




**Exercise 5.1**
The following tasks are concerned with converting and checking data types:

- What happens if you apply as.logical to the numeric values 0 and 1? What happens if you apply it to other numbers?

```{r}
as.logical(0) # FALSE
as.logical(1) # TRUE
as.logical(123)  # TRUE
```

- What happens if you apply as.character to a vector containing numeric values?

```{r}
as.character(c(1,2,3,pi,sqrt(22))) # all converted
```

- The functions is.logical, is.numeric and is.character can be used to check if a variable is a logical, numeric or character, respectively. 
What type of object do they return?

```{r}
is.numeric(123)
is.numeric("123")

```

- Is NA a logical, numeric or character?

```{r}
is.logical(NA)
is.numeric(NA) 
is.character(NA)
```

?NA  -> "ºNA is a logical constant of length 1 which contains a missing value indicator. ..."


## 5.2 Working with lists

A data structure that is very convenient for storing data of different types is list. You can think of a list as a data frame
where you can put different types of objects in each column: like a numeric vector of length 5 in the first, a data frame in the second,
and a single character in the third. 
Here is an example of how to create a list using the function of the same name:

```{r}
my_list <- list(my_numbers = c(86, 42, 57, 61, 22),
                my_data = data.frame(a = 1:3, b = 4:6),
                my_text = "Lists are the best.")

my_list
```

To access the elements in the list, we can use the same $ notation as for data frames:

```{r}
my_list$my_numbers
my_list$my_text
my_list$my_data$a[3]
```

In addition, we can access them using indices, but using double brackets:

```{r}
my_list[[1]]
#my_list[[2]]
my_list[[3]]
```

To access elements within the elements of lists, additional brackets can be added.
For instance, if you wish to access the second element of the my_numbers vector, you can use either of these:

```{r}
my_list[[1]][2]
my_list$my_numbers[2]
```


### Splitting vectors into lists

Consider the airquality dataset, which among other things describes the temperature on each day during a five-month period.
Suppose that we wish to split the airquality$Temp vector into five separate vectors: one for each month.
We could do this by repeated filtering, e.g.,

```{r}
temp_may <- airquality$Temp[airquality$Month == 5]
temp_june <- airquality$Temp[airquality$Month == 6]
# ...and so on.
```

Apart from the fact that this isn’t a very good-looking solution, this would be infeasible if we needed to split our vector 
into a larger number of new vectors. Fortunately, there is a function that allows us to split the vector by month,
storing the result as a list - **split**:

```{r}
temps <- split(airquality$Temp, airquality$Month)
temps
```


```{r}
# To access the temperatures for June:
temps$`6`
temps[[2]]
```


```{r}
# To give more informative names to the elements in the list:
names(temps) <- c("May", "June", "July", "August", "September")
temps$June
```

Note that, in breach of the rules for variable names in R, the original variable names here were numbers 
(actually character variables that happened to contain numeric characters). 
When accessing them using $ notation, you need to put them between backticks (`), e.g., temps$`6`, 
to make it clear that 6 is a variable name and not a number.


### Collapsing lists into vectors

Conversely, there are times where you want to collapse a list into a vector. This can be done using **unlist**:

```{r}
original <- unlist(temps)
original
```


**Exercise 5.2**
Load the vas.csv data from Exercise 2.30. Split the VAS vector so that you get a list containing one vector for each patient. 
How can you then access the visual analogue scale (VAS) values for patient 212?

```{r}
vas <- read.csv("vas.csv", sep = ";", dec = ",", skip = 4)
```

```{r}
vas_split <- split(vas$VAS, vas$ID)

vas_split$`212`
vas_split[[12]]
```


## 5.3 Working with numbers

A lot of data analyses involve numbers, which typically are represented as **numeric** values in R.
..

### Rounding numbers

At times you may want to round numbers, either for presentation purposes or for some other reason.
There are several functions that can be used for this:

```{r}
a <- c(2.1241, 3.86234, 4.5, -4.5, 10000.1001)

round(a, 3)           # Rounds to 3 decimal places
signif(a, 3)          # Rounds to 3 significant digits
```


```{r}
ceiling(a)            # Rounds up to the nearest integer
floor(a)              # Rounds down to the nearest integer

trunc(a)              # Rounds to the nearest integer, toward 0
                      # (note the difference in how 4.5
                      #  and -4.5 are treated!)
```


### Sums and means in data frames

When working with numerical data, you’ll frequently find yourself wanting to compute sums or means of either columns or rows of data frames. 
The **colSums, rowSums, colMeans and rowMeans** functions can be used to do this. Here is an example with an expanded version of the bookstore data, 
where three purchases have been recorded for each customer:

```{r}
bookstore2 <- data.frame(purchase1 = c(20, 59, 2, 12, 22, 160,
                                       34, 34, 29),
                         purchase2 = c(14, 67, 9, 20, 20, 81,
                                       19, 55, 8),
                         purchase3 = c(4, 62, 11, 18, 33, 57,
                                       24, 49, 29))
bookstore2
```


```{r}
colSums(bookstore2)   # The total amount for customers' 1st, 2nd and 3rd purchases
rowSums(bookstore2)   # The total amount for each customer
colMeans(bookstore2)  # Mean purchase for 1st, 2nd and 3rd purchases
rowMeans(bookstore2)  # Mean purchase for each customer
```

Moving beyond sums and means, in Section 6.5 you’ll learn how to apply any function to the rows or columns of a data frame.


### Summaries of series of numbers

When a numeric vector contains a series of consecutive measurements, as is the case, e.g., in a time series, it is often of interest
to compute various cumulative summaries. For instance, if the vector contains the daily revenue of a business during a month, 
it may be of value to know the total revenue up to each day, that is, the cumulative sum for each day.

Let’s return to the **a10** data from Section 4.7, which described the monthly anti-diabetic drug sales in Australia during 1991-2008.

```{r}
library(fpp2)
a10
```

Elements 7 to 18 contain the sales for 1992. We can compute the total, highest, and smallest monthly sales up to and including each month
**using cumsum, cummax, and cummin**:

```{r}
#a10[7:18]
cumsum(a10[7:18])  # Total sales
cummax(a10[7:18])  # Highest monthly sales
cummin(a10[7:18])  # Lowest monthly sales
```


```{r}
# Plot total sales up to and including each month:
plot(1:12, cumsum(a10[7:18]),
     xlab = "Month",
     ylab = "Total sales",
     type = "b")
```

In addition, the cumprod function can be used to compute cumulative products.

At other times, we are interested in studying run lengths in series, that is, the lengths of runs of equal values in a vector. 
Consider the upp_temp vector defined in the code chunk below, which contains the daily temperatures in Uppsala, Sweden, in February 2020.

```{r}
upp_temp <- c(5.3, 3.2, -1.4, -3.4, -0.6, -0.6, -0.8, 2.7, 4.2, 5.7,
              3.1, 2.3, -0.6, -1.3, 2.9, 6.9, 6.2, 6.3, 3.2, 0.6, 5.5,
              6.1, 4.4, 1.0, -0.4, -0.5, -1.5, -1.2, 0.6)
```


It could be interesting to look at runs of sub-zero days, i.e., consecutive days with sub-zero temperatures.
The **rle** function counts the lengths of runs of equal values in a vector. To find the length of runs of temperatures below or above zero
we can use the vector defined by the condition upp_temp < 0, the values of which are TRUE on sub-zero days and FALSE when the temperature is 0 or higher.
When we apply rle to this vector, it returns the length and value of the runs:

```{r}
rle(upp_temp < 0)
```

We first have a 2-day run of above zero temperatures (FALSE), then a 5-day run of sub-zero temperatures (TRUE), then a 5-day run of above zero temperatures, and so on.


### Scientific notation: 1e-03

When printing very large or very small numbers, R uses scientific notation, meaning that 7,000,000 (7 followed by 6 zeroes) is displayed as
(the mathematically equivalent) 7⋅106, and 0.0000007 is displayed as 7⋅10−7. Well, almost, the 10 raised to the power of x bit isn’t really displayed as 10x,
but as e+x, a notation used in many programming languages and calculators. 
Here are some examples:

```{r}
7000000
0.0000007
7e+07
exp(30)
```

Scientific notation is a convenient way to display very large and very small numbers, but it’s not always desirable.
If you just want to print the number, the format function can be used to convert it to a character, suppressing scientific notation:

```{r}
format(7000000)
format(7000000, scientific = FALSE)
```

If you still want your number to be a numeric (as you often do), a better choice is to change the option for when R uses scientific notation.
This can be done using the scipen argument in the options function:

```{r}
options(scipen = 1000)

7000000
0.0000007
7e+07
exp(30)
```

To revert this option back to the default, you can use:

```{r}
options(scipen = 0)

7000000
0.0000007
7e+07
exp(30)
```

Note that this option only affects how R prints numbers, and not how they are treated in computations.


### Floating point arithmetics

Some numbers cannot be written in finite decimal forms. Take 1/3 for example, the decimal form of which is 0.33333333333333333333333333333333….

Clearly, the computer cannot store this number exactly, as that would require an infinite memory. Because of this, numbers in computers are stored 
as floating point numbers, which aim to strike a balance between range (being able to store both very small and very large numbers) 
and precision (being able to represent numbers accurately). 
Most of the time, calculations with floating points yield exactly the results that we’d expect, but sometimes these non-exact representations 
of numbers will cause unexpected problems. If we wish to compute 1.5−0.2 and 1.1−0.2, say, we could of course use R for that.
Let’s see if it gets the answers right:

```{r}
1.5 - 0.2
1.5 - 0.2 == 1.3  # Check if 1.5-0.2=1.3
```


```{r}
1.1 - 0.2
1.1 - 0.2 == 0.9  # Check if 1.1-0.2=0.9
```

The limitations of floating point arithmetics cause the second calculation to fail. To see what has happened, 
we can use sprintf to print numbers with 30 decimals (by default, R prints a rounded version with fewer decimals):

```{r}
sprintf("%.30f", 1.1 - 0.2)
sprintf("%.30f", 0.9)
```

The first 12 decimals are identical, but after that the two numbers 1.1 - 0.2 and 0.9 diverge. 
In our other example, 1.5−0.2, we don’t encounter this problem – both 1.5 - 0.2 and 0.3 have the same floating point representation:

```{r}
sprintf("%.30f", 1.5 - 0.2)
sprintf("%.30f", 1.3)
```

The order of the operations also matters in this case. The following three calculations would all yield identical results 
if performed with real numbers, but in floating point arithmetics the results differ:

```{r}
1.1 - 0.2 - 0.9
1.1 - 0.9 - 0.2
1.1 - (0.9 + 0.2)
```


In most cases, it won’t make a difference whether a variable is represented as 0.90000000000000013… or 0.90000000000000002…, 
but in some cases tiny differences like that can propagate and cause massive problems. A famous example of this involves
the US Patriot surface-to-air defence system, which at the end of the first Gulf War missed an incoming missile due to an error in floating point arithmetics. 
It is important to be aware of the fact that floating point arithmetics occasionally will yield incorrect results. 
This can happen for numbers of any size, but it is more likely to occur when very large and very small numbers appear in the same computation.

So, 1.1 - 0.2 and 0.9 may not be the same thing in floating point arithmetics, but at least they are nearly the same thing. 
The == operator checks if two numbers are exactly equal, but there is an alternative that can be used to check if two numbers are nearly equal: **all.equal**. 
If the two numbers are (nearly) equal, it returns TRUE, and if they are not, it returns a description of how they differ. 
In order to avoid the latter, we can use the **isTRUE** function to return FALSE instead:

```{r}
1.1 - 0.2 == 0.9
all.equal(1.1 - 0.2, 0.9)
all.equal(1, 2)
isTRUE(all.equal(1, 2))
isTRUE(all.equal(0.1, 1.1 - 0.2 - 0.8))
```




**Exercise 5.3**
These tasks showcase some problems that are commonly faced when working with numeric data:

- The vector props <- c(0.1010, 0.2546, 0.6009, 0.0400, 0.0035) contains proportions (which, by definition, are between 0 and 1). Convert the proportions to percentages with one decimal place.

```{r}
props <- c(0.1010, 0.2546, 0.6009, 0.0400, 0.0035)
round(100 * props, 1)
```

- Compute the highest and lowest temperatures up to and including each day in the airquality dataset.

```{r}
cummax(airquality$Temp)
cummin(airquality$Temp)
```
 
The minimum during the period occurs on the 5th day (56), whereas the maximum occurs during day 120 (97).

- What is the longest run of days with temperatures above 80 in the airquality dataset?

```{r}
runs <- rle(airquality$Temp > 80)

runs$lengths[runs$values == TRUE]
```

We see that the longest run was 23 days.


**Exercise 5.4**
These tasks are concerned with floating point arithmetics:

- Very large numbers, like 10e500, are represented by Inf (infinity) in R. Try to find out what the largest number that can be represented as a floating point number in R is.

"On virtually all systems, the largest number that R can represent as a floating point is 1.797693e+308. You can find this by gradually trying larger and larger numbers:"

```{r}
1e+100
1e+200
1e+300

1e+305

1e+308
100e+308
1e+309

1e+500
1e+1000
```


- Due to an error in floating point arithmetics, sqrt(2)^2 - 2 is not equal to 0. Change the order of the operations so that the results is 0.

```{r}
sqrt(2)^2 - 2  # Not 0
sqrt(2^2) - 2  # 0
```












