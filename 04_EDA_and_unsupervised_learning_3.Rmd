---
title: "04_EDA_and_unsupervised_learning_3"
author: "Fran Camacho"
date: "2025-08-27"
output: word_document
---

# 4 - Exploratory data analysis and unsupervised learning

https://modernstatisticswithr.com/eda.html#polar

```{r}
#Libraries

#https://tidyverse.r-universe.dev/tidyverse
if (!require(tidyverse)) install.packages('tidyverse', repos = c('https://tidyverse.r-universe.dev', 'https://cloud.r-project.org'))
library(tidyverse)

```


## 4.8 Using polar coordinates

Most plots are made using Cartesian coordinate systems, in which the axes are orthogonal to each other and values are placed
in an even spacing along each axis. In some cases, non-linear axes (e.g., log-transformed) are used instead, as we have already seen.

Another option is to use a polar coordinate system, in which positions are specified using an angle and a (radial) distance from the origin.
Here is an example of a polar scatterplot, where sleep_rem is represented by the angle and sleep_total by the radial distance:

```{r}
ggplot(msleep, aes(sleep_rem, sleep_total, colour = vore)) + 
      geom_point() +
      labs(x = "REM sleep (circular axis)",
           y = "Total sleep time (radial axis)") +
      coord_polar()
```

### Visualising periodic data

Polar coordinates are particularly useful when the data is periodic. Consider for instance the following dataset, 
describing monthly weather averages for Cape Town, South Africa:

```{r}
Cape_Town_weather <- data.frame(
  Month = 1:12,
  Temp_C = c(22, 23, 21, 18, 16, 13, 13, 13, 14, 16, 18, 20),
  Rain_mm = c(20, 20, 30, 50, 70, 90, 100, 70, 50, 40, 20, 20),
  Sun_h = c(11, 10, 9, 7, 6, 6, 5, 6, 7, 9, 10, 11)
  )
```

We can visualise the monthly average temperature using lines in a Cartesian coordinate system:

```{r}
ggplot(Cape_Town_weather, aes(Month, Temp_C)) +
      geom_line()
```

```{r}
## To show both variables at the same time, they must be put in aes withing geom_line
ggplot(Cape_Town_weather, aes(x = Month)) +
  geom_line(aes(y = Temp_C, color = "Temperature")) +
  geom_line(aes(y = Rain_mm, color = "Rainfall")) +
  theme_minimal()
```

What this plot doesn’t show is that the 12th month and the 1st month actually are consecutive months.
If we instead use polar coordinates, this becomes clearer:

```{r}
ggplot(Cape_Town_weather, aes(Month, Temp_C)) +
      geom_line() +
      coord_polar()
```

To improve the presentation, we can change the scale of the x-axis (i.e., the circular axis) so that January and December aren’t plotted at the same angle:

```{r}
ggplot(Cape_Town_weather, aes(Month, Temp_C)) +
      geom_line() +
      coord_polar() +
      xlim(0, 12)
```

**Exercise 4.17**
In the plot that we just created, the last and first month of the year aren’t connected. 
You can fix manually this by adding a cleverly designed faux data point to Cape_Town_weather. How?

"By adding a copy of the observation for month 12, with the Month value replaced by 0, we can connect the endpoints to form a continuous curve:"

```{r}
Cape_Town_weather[13,] <- Cape_Town_weather[12,]
Cape_Town_weather$Month[13] <- 0

ggplot(Cape_Town_weather, aes(Month, Temp_C)) +
      geom_line() +
      coord_polar() +
      xlim(0, 12)
```


### Pie charts

Consider the stacked bar chart that we plotted in Section 2.8:

```{r}
ggplot(msleep, aes(factor(1), fill = vore)) +
      geom_bar()
```

What would happen if we plotted this figure in a polar coordinate system instead? 
If we map the height of the bars (the y-axis of the Cartesian coordinate system) to both the angle and the radial distance, we end up with a pie chart:

```{r}
ggplot(msleep, aes(factor(1), fill = vore)) +
      geom_bar() +
      coord_polar(theta = "y")
```

There are many arguments against using pie charts for visualisations. Most boil down to the fact that the same information 
is easier to interpret when conveyed as a bar chart. This is at least partially due to the fact that most people are more 
used to reading plots in Cartesian coordinates than in polar coordinates.

If we make a similar transformation of a grouped bar chart, we get a different type of pie chart, in which the height 
of the bars is mapped to both the angle and the radial distance:

Cartesian bar chart:

```{r}
# Cartesian bar chart:
ggplot(msleep, aes(vore, fill = vore)) +
      geom_bar() +
      theme(legend.position = "none")
```

Polar bar chart:

```{r}
# Polar bar chart:
ggplot(msleep, aes(vore, fill = vore)) +
      geom_bar() +
      coord_polar() +
      theme(legend.position = "none")
```


## 4.9 Visualising multiple variables

### Scatterplot matrices

When we have a large enough number of numeric variables in our data, plotting scatterplots of all pairs of variables becomes tedious. 
Luckily there are some R functions that speed up this process.

The **GGally** package is an extension to ggplot2 which contains several functions for plotting multivariate data.
They work similarly to the autoplot functions that we have used in previous sections. One of these is **ggpairs**, 
which creates a scatterplot matrix, a grid with scatterplots of all pairs of variables in data.
In addition, it also plots density estimates (along the diagonal) and shows the (Pearson) correlation for each pair. 

Let’s start by installing GGally:

```{r}
#  useful functions for plotting multivariate data
if (!require(GGally)) install.packages('GGally', dependencies = T)
library(GGally)

```

```{r fig.width=12, warning=FALSE, message=FALSE}
library(GGally)

ggpairs(airquality)
```

If we want to create a scatterplot matrix but only want to include some of the variables in a dataset, we can do so by providing a vector with variable names. Here is an example for the animal sleep data msleep.

Without pipes:

```{r fig.width=12, warning=FALSE, message=FALSE}
ggpairs(msleep[, c("sleep_total", "sleep_rem", "sleep_cycle", "awake","brainwt", "bodywt")])
```
```{ r fig.width=12, warning=FALSE, message=FALSE}

# using pipes
library(dplyr)

msleep |>
  select(sleep_total, sleep_rem, sleep_cycle, awake, brainwt, bodywt) |> 
  ggpairs()
```


Optionally, if we wish to create a scatterplot involving all numeric variables, we can replace the vector with variable names
with some R code that extracts the columns containing numeric variables:

Without pipes:

```{r fig.width=12, warning=FALSE, message=FALSE}
ggpairs(msleep[, which(sapply(msleep, class) == "numeric")])
```

```{r fig.width=12, warning=FALSE, message=FALSE}
msleep |>
  select(where(is.numeric)) |> 
  ggpairs()
```

...

If we include a categorical variable in the list of variables (such as the feeding behaviour vore), 
the matrix will include a bar plot of the categorical variable as well as boxplots and facetted histograms 
to show differences between different categories in the continuous variables:

```{r fig.width=12, warning=FALSE, message=FALSE}
ggpairs(msleep[, c("vore", "sleep_total", "sleep_rem", "sleep_cycle",
                   "awake", "brainwt", "bodywt")])
```

Alternatively, we can use a categorical variable to colour points and density estimates using aes(colour = ...). 
The syntax for this follows the same pattern as that for a standard ggplot call - ggpairs(data, aes).
The only exception is that if the categorical variable is not included in the data argument, we must specify which data frame it belongs to:

```{r fig.width=12, warning=FALSE, message=FALSE}
ggpairs(msleep[, c("sleep_total", "sleep_rem", "sleep_cycle", "awake","brainwt", "bodywt")],
        aes(colour = msleep$vore, alpha = 0.5))
```


As a side note, if all variables in your data frame are numeric, and if you only are looking for a quick-and-dirty scatterplot matrix 
without density estimates and correlations, you can also use the base R plot:

```{r fig.width=12, warning=FALSE, message=FALSE}
plot(airquality)
```

**Exercise 4.18** 
Create a scatterplot matrix for all numeric variables in diamonds. Differentiate different cuts by colour. 
Add a suitable title to the plot. 
(diamonds is a fairly large dataset, and it may take a minute or so for R to create the plot.)

```{r fig.width=12, warning=FALSE, message=FALSE}
ggpairs(diamonds[, which(sapply(diamonds, class) == "numeric")],
        aes(colour = diamonds$cut, alpha = 0.5)) +
      ggtitle("Numeric variables in the diamonds dataset")
```


### 3D scatterplots

The **plotly** package lets us make three-dimensional scatterplots with the **plot_ly** function, which can be a useful alternative 
to scatterplot matrices in some cases. Here is an example using the airquality data:

```{r warning=FALSE, message=FALSE}
library(plotly)

plot_ly(airquality, x = ~Ozone, y = ~Wind, z = ~Temp,
        color = ~factor(Month))
```


### Correlograms

Scatterplot matrices are not a good choice when we have too many variables, partially because the plot window needs to be very large 
to fit all variables and partially because it becomes difficult to get a good overview of the data.
In such cases, a correlogram, where the strength of the correlation between each pair of variables is plotted instead of scatterplots, 
can be used instead. 
It is effectively a visualisation of the correlation matrix of the data, where the strengths and signs of the correlations are represented by different colours.

The **GGally** package contains the function **ggcorr**, which can be used to create a correlogram:

```{r}
library(GGally)

ggcorr(msleep[, c("sleep_total", "sleep_rem", "sleep_cycle", "awake", "brainwt", "bodywt")])
```



**Exercise 4.19**
Using the diamonds dataset and the documentation for ggcorr, do the following:

- Create a correlogram for all numeric variables in the dataset.

```{r}
library(GGally)

#ggcorr(diamonds)
ggcorr(diamonds[, which(sapply(diamonds, class) == "numeric")])
```

- The Pearson correlation that ggcorr uses by default isn’t always the best choice. A commonly used alternative is the Spearman correlation.
Change the type of correlation used to create the plot to the Spearman correlation.

```{r}
ggcorr(diamonds[, which(sapply(diamonds, class) == "numeric")],
       method = c("pairwise", "spearman"))
```

- Change the colour scale from a categorical scale with five categories.

```{r}
ggcorr(diamonds[, which(sapply(diamonds, class) == "numeric")],
       method = c("pairwise", "spearman"),
       nbreaks = 5)
```

- Change the colours on the scale to go from yellow (low correlation) to black (high correlation).

```{r}
ggcorr(diamonds[, which(sapply(diamonds, class) == "numeric")],
       method = c("pairwise", "spearman"),
       nbreaks = 5,
       low = "yellow", high = "black")
```

### Adding more variables to scatterplots

We have already seen how scatterplots can be used to visualize two continuous and one categorical variable by plotting the two continuous variables
against each other and using the categorical variable to set the colours of the points. 
There are, however, more ways we can incorporate information about additional variables into a scatterplot.

So far, we have set three aesthetics in our scatterplots: x, y, and colour. Two other important aesthetics are shape and size, 
which, as you’d expect, allow us to control the shape and size of the points. 
As a first example using the msleep data, we use feeding behaviour (vore) to set the shapes used for the points:

```{r}
ggplot(msleep, aes(brainwt, sleep_total, color = vore, shape = vore)) +   # color + shape
      geom_point() +
      scale_x_log10()
```

The plot looks a little nicer if we increase the size of the points:

```{r}
ggplot(msleep, aes(brainwt, sleep_total, color = vore, shape = vore, size = 2)) +   # color + shape
      geom_point() +
      scale_x_log10()
```

Another option is to let size represent a continuous variable, in what is known as a bubble plot:

```{r}
ggplot(msleep, aes(brainwt, sleep_total, colour = vore,
                   size = bodywt)) +
      geom_point() +
      scale_x_log10()
```

The size of each “bubble” now represents the weight of the animal. Because some animals are much heavier (i.e., have higher bodywt values) than most others,
almost all points are quite small. There are a couple of things we can do to remedy this. 
First, we can transform bodywt, e.g., using the square root transformation sqrt(bodywt), to decrease the differences between large and small animals. 
This can be done by adding scale_size(trans = "sqrt") to the plot. Second, we can also use scale_size to control the range of point sizes (e.g., from size 1 to size 20).
This will cause some points to overlap, so we add alpha = 0.5 to the geom, to make the points transparent:

```{r}
ggplot(msleep, aes(brainwt, sleep_total, colour = vore,
                   size = bodywt)) +
      geom_point(alpha = 0.5) +
      scale_x_log10() +
      scale_size(range = c(1, 20), trans = "sqrt")
```

This produces a fairly nice-looking plot, but it’d look even better if we changed the axes labels and legend texts.
We can change the legend text for the size scale by adding the argument name to labs. Including a \n in the text lets us create a line break 
– you’ll learn more tricks like that in Section 5.5.

```{r}
ggplot(msleep, aes(brainwt, sleep_total, colour = vore,
                   size = bodywt)) +
      geom_point(alpha = 0.5) +
      labs(x = "Brain weight (logarithmic scale)",
           y = "Total sleep time",
           size = "Square root of\nbody weight",
           colour = "Feeding behaviour") +
      scale_x_log10() +
      scale_size(range = c(1, 20), trans = "sqrt")
```

**Exercise 4.20**
Using the bubble plot created above, do the following:

- Replace colour = vore in the aes by fill = vore and add colour = "black", shape = 21 to geom_point. What happens?

```{r}
ggplot(msleep, aes(brainwt, sleep_total, fill = vore, size = bodywt)) +
      geom_point(alpha = 0.5, colour = "black", shape = 21) +
      labs(x = "log(Brain weight)",
           y = "Sleep total (h)") +
      scale_x_log10() +
      scale_size(range = c(1, 20), trans = "sqrt",
                 name = "Square root of\nbody weight") +
      scale_color_discrete(name = "Feeding behaviour")
```

"The points now get black borders, which makes them a bit sharper"

- Use ggplotly to create an interactive version of the bubble plot above, where variable information and the animal name are displayed when you hover a point.

```{r}
library(plotly)

myPlot <- ggplot(msleep, aes(brainwt, sleep_total, fill = vore,
                             size = bodywt, text = name)) +
      geom_point(alpha = 0.5, colour = "black", shape = 21) +
      labs(x = "log(Brain weight)",
           y = "Sleep total (h)") +
      scale_x_log10() +
      scale_size(range = c(1, 20), trans = "sqrt",
                 name = "Square root of\nbody weight") +
      scale_color_discrete(name = "Feeding behaviour")

ggplotly(myPlot)
```


### Overplotting

Let’s make a scatterplot of table versus depth based on the diamonds dataset:

```{r}
ggplot(diamonds, aes(table, depth)) +
      geom_point()
```

This plot is cluttered. There are too many points, which makes it difficult to see if, for instance, high table values are more common than low table values.
In this section, we’ll look at some ways to deal with this problem, known as **overplotting**.

The first thing we can try is to decrease the point size:

```{r}
ggplot(diamonds, aes(table, depth)) +
      geom_point(size = 0.1)
```

This helps a little, but now the outliers become a bit difficult to spot. We can try changing the opacity using alpha instead:

```{r}
ggplot(diamonds, aes(table, depth)) +
      geom_point(alpha = 0.2)
```

This is also better than the original plot, but neither plot is great. Instead of plotting each individual point,
maybe we can try plotting the counts or densities in different regions of the plot instead? 
Effectively, this would be a two-dimensional version of a histogram. There are several ways of doing this in ggplot2.

First, we bin the points and count the numbers in each bin, using **geom_bin2d**:

```{r}
ggplot(diamonds, aes(table, depth)) +
      geom_bin2d()
```

By default, geom_bin2d uses 30 bins. Increasing that number can sometimes give us a better idea about the distribution of the data:

```{r}
ggplot(diamonds, aes(table, depth)) +
      geom_bin2d(bins = 50)
```

If you prefer, you can get a similar plot with hexagonal bins by using geom_hex instead:

```{r}
ggplot(diamonds, aes(table, depth)) +
      geom_hex(bins = 50)
```

As an alternative to bin counts, we could create a two-dimensional density estimate and create a contour plot showing the levels of the density:

```{r}
ggplot(diamonds, aes(table, depth)) +
      stat_density_2d(aes(fill = ..level..), geom = "polygon", colour = "red")
```

The fill = ..level.. bit above probably looks a little strange to you. It means that an internal function (the level of the contours)
is used to choose the fill colours. It also means we’re reaching deep into the depths of ggplot2!

We can use a similar approach to show a summary statistic for a third variable in a plot. 
For instance, we may want to plot the average price as a function of table and depth. 
This is called a tile plot:

```{r}
ggplot(diamonds, aes(table, depth, z = price)) +
     geom_tile(binwidth = 1, stat = "summary_2d", fun = mean) +
     ggtitle("Mean prices for diamonds with different depths and tables")
```


**Exercise 4.21**
The following tasks involve the diamonds dataset:

- Create a tile plot of table versus depth, showing the highest price for a diamond in each bin.

```{r warning = FALSE}
ggplot(diamonds, aes(table, depth, z = price)) +
      geom_tile(binwidth = 1, stat = "summary_2d", fun = max) +
      ggtitle("Highest prices for diamonds with different depths and tables")
```


- Create a bin plot of carat versus price. What type of diamonds have the highest bin counts?

```{r warning = FALSE}
ggplot(diamonds, aes(carat, price)) +
      geom_hex(bins = 50)
```

Diamonds with carats 0.25-0.3 and price ~1000


### Categorical data

When visualising a pair of categorical variables, plots similar to those in the previous section prove to be useful. 
One way of doing this is to use the **geom_count** geom. We illustrate this with an example using diamonds,
showing how common different combinations of colours and cuts are:

```{r}
ggplot(diamonds, aes(color, cut)) +
      geom_count()
```

However, it is often better to use colour rather than point size to visualise counts, which we can do using a tile plot.
First, we have to compute the counts though, using aggregate. We now wish to have two grouping variables, color and cut,
which we can put on the right-hand side of the formula as follows:

```{r}
diamonds2 <- aggregate(carat ~ cut + color, data = diamonds, FUN = length)

diamonds2
```

diamonds2 is now a data frame containing the different combinations of color and cut along with counts of how many diamonds belong 
to each combination (labelled carat, because we put carat in our formula). 
Let’s change the name of the last column from carat to Count:

```{r}
names(diamonds2)[3] <- "Count"
```

Next, we can plot the counts using geom_tile:

```{r}
ggplot(diamonds2, aes(color, cut, fill = Count)) +
      geom_tile()
```


It is also possible to combine point size and colours:

```{r}
ggplot(diamonds2, aes(color, cut, colour = Count, size = Count)) +
      geom_count()
```


**Exercise 4.22**
Using the diamonds dataset, do the following:

- Use a plot to find out what the most common combination of cut and clarity is.

```{r}
diamonds2 <- aggregate(carat ~ cut + clarity, data = diamonds, FUN = length)

names(diamonds2)[3] <- "Count"

ggplot(diamonds2, aes(clarity, cut, fill = Count)) +
      geom_tile()
```

Ideal and VS2 is the most common combination


- Use a plot to find out which combination of cut and clarity has the highest average price.

As for continuous variables, we can use geom_tile with the arguments stat = "summary_2d", fun = mean
to display the average prices for different combinations. 

```{r}
ggplot(diamonds, aes(clarity, cut, z = price)) +
      geom_tile(binwidth = 1, stat = "summary_2d", fun = mean) +
      ggtitle("Mean prices for diamonds with different clarities and cuts")
```

Premium and SI2 is the combination with the highest average price.


### Putting it all together

In the next two exercises, you will repeat what you have learned so far by investigating the gapminder and planes datasets.
First, load the corresponding libraries and have a look at the documentation for each dataset:

```{r}
install.packages("gapminder")
library(gapminder)
?gapminder

library(nycflights13)
?planes
```



**Exercise 4.23**
Do the following using the gapminder dataset:

- Create a scatterplot matrix showing life expectancy, population, and GDP per capita for all countries, using the data from the year 2007.
Use colours to differentiate countries from different continents. Note: you’ll probably need to add the argument upper = list(continuous = "na")
when creating the scatterplot matrix. By default, correlations are shown above the diagonal, but the fact that there only are two countries 
from Oceania will cause a problem there – at least three points are needed for a correlation test.

```{r}
gapminder2007 <- gapminder[gapminder$year == 2007,]

ggpairs(gapminder2007[, c("lifeExp", "pop", "gdpPercap")],
        aes(colour = gapminder2007$continent, alpha = 0.5),
        upper = list(continuous = "na"))
```


- Create an interactive bubble plot, showing information about each country when you hover the points. Use data from the year 2007. 
Put log(GDP per capita) on the x-axis and life expectancy on the y-axis. Let population determine point size.
Plot each country in a different colour and facet by continent. 
Tip: the gapminder package provides a pretty colour scheme for different countries, called country_colors. 
You can use that scheme by adding scale_colour_manual(values = country_colors) to your plot.

```{r}
library(plotly)

gapminder2007 <- gapminder[gapminder$year == 2007,]

myPlot <- ggplot(gapminder2007, aes(gdpPercap, lifeExp, size = pop, colour = country)) +
      geom_point(alpha = 0.5) +
      scale_x_log10() +
      scale_size(range = c(2, 15)) +
      scale_colour_manual(values = country_colors) +
      theme(legend.position = "none") +
      facet_wrap(~ continent)

ggplotly(myPlot)
```



**Exercise 4.24**
Use graphics to answer the following questions regarding the planes dataset:

- What is the most common combination of manufacturer and plane type in the dataset?

```{r fig.width=10}
library(nycflights13)
library(ggplot2)

planes2 <- aggregate(tailnum ~ type + manufacturer, data = planes, FUN = length)

ggplot(planes2, aes(type, manufacturer, fill = tailnum)) +
      geom_tile()
```

Boeing and fixed wing is the most common combination


- Which combination of manufacturer and plane type has the highest average number of seats?

```{r fig.width=10}
ggplot(planes, aes(type, manufacturer, z = seats)) +
      geom_tile(binwidth = 1, stat = "summary_2d", fun = mean) +
      ggtitle("Number of seats for different planes")
```

The fixed wing multi engine Airbus has the highest average number of seats

- Do the numbers of seats on planes change over time? Which plane had the highest number of seats?

```{r fig.width=10, warning=FALSE, message=FALSE}
ggplot(planes, aes(year, seats)) +
      geom_point(aes(colour = engine)) +
      geom_smooth()
```

"The number of seats seems to have increased in the 1980’s, and then reached a plateau".

The plane with the largest number of seats is not an Airbus, but a Boeing 747-451.
It can be found using planes[which.max(planes$seats),] or visually using plotly:

```{r fig.width=10, warning=FALSE, message=FALSE}
myPlot <- ggplot(planes, aes(year, seats,
                             text = paste("Tail number:", tailnum,
                                          "<br>Manufacturer:",
                                          manufacturer))) +
      geom_point(aes(colour = engine)) +
      geom_smooth()

ggplotly(myPlot)
```



- Does the type of engine used change over time?

```{r fig.width=10, warning=FALSE, message=FALSE}
ggplot(planes, aes(year, seats)) +
      geom_point(aes(colour = engine)) +
      geom_smooth()
```


## 4.10 Sankey diagrams

A **Sankey diagram** is a type of flow diagram used to show flows from one state to another. We’ll consider an example with data from a medical trial. 
Patients were recruited from four hospitals and assigned to one of two treatments: either surgery or physiotherapy. 
At the end of the study, they had either recovered or not. 
The data is in the surgphys.csv file, which can be downloaded from the book’s web page.

Set file_path to the path of surgphys.csv to load the data:

```{r}
surgphys <- read.csv("surgphys.csv")

View(surgphys)
```


We’ll use the ggsankey package for creating the diagram, so let’s install that:

```{r}
install.packages("remotes")
remotes::install_github("davidsjoberg/ggsankey")
```

First, we need to reformat the data by pointing out the order of the different “states”. 
In this case, patients are first recruited at a hospital, then assigned a treatment, and then an outcome is observed. 
The **make_longer** function from ggsankey formats the data to reflect this:

```{r}
library(ggsankey)

surgphys |> make_long(Hospital, Treatment, Outcome) -> surgphys_sankey
```


Next, we create a ggplot using the variables we just created, and add the geom_sankey geom:

```{r fig.width=10, warning=FALSE, message=FALSE}

ggplot(surgphys_sankey, aes(x = x,
                            next_x = next_x,
                            node = node,
                            next_node = next_node,
                            fill = factor(node),
                            label = node)) +
  geom_sankey()
```

To make this a little prettier, we can change some settings for geom_sankey, add labels with geom_sankey_label, 
and change the theme settings and colour palette:

```{r fig.width=10, warning=FALSE, message=FALSE}

ggplot(surgphys_sankey, aes(x = x,
                          next_x = next_x,
                          node = node,
                          next_node = next_node,
                          fill = factor(node),
                          label = node)) +
    geom_sankey(flow.alpha = 0.5,
                node.color = "black",
                show.legend = FALSE) + 
    geom_sankey_label(size = 3,
                      colour = "black",
                      fill = "white",
                      hjust = -0.3) +
    theme_minimal() +
    theme(axis.title = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks = element_blank(),  
          panel.grid = element_blank()) +
    scale_fill_manual(values = c("darkorange", "skyblue",
                                 "forestgreen", "#00AFBB",
                                 "#E7B800", "#FC4E07",
                                 "deeppink", "purple"))
```

If we want to show the number of patients in each state, we can add counts to the data, and then add them to the node labels as follows
(see Section 5.12 for an explanation of what right_join does):

```{r fig.width=10, warning=FALSE, message=FALSE}
library(dplyr)

surgphys_sankey |> 
  group_by(node)|>
  count() |> 
  right_join(surgphys_sankey, by = "node") -> surgphys_sankey

ggplot(surgphys_sankey, aes(x = x,
                          next_x = next_x,
                          node = node,
                          next_node = next_node,
                          fill = factor(node),
                          label = paste0(node," (n=", n, ")"))) +
    geom_sankey(flow.alpha = 0.5,
                node.color = "black",
                show.legend = FALSE) + 
    geom_sankey_label(size = 3,
                      colour = "black",
                      fill = "white",
                      hjust = -0.15) +
    theme_minimal() +
    theme(axis.title = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks = element_blank(),  
          panel.grid = element_blank()) +
    scale_fill_manual(values = c("darkorange", "skyblue",
                                 "forestgreen", "#00AFBB",
                                 "#E7B800", "#FC4E07",
                                 "deeppink", "purple"))
```

